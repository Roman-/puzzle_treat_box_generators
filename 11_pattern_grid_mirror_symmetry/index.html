<!doctype html>
<meta charset="utf-8">
<title>Pattern Grid Deduction (Mirror Symmetry) â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=1200 min=100></label>
<label>H <input id=h type=number value=400 min=100></label>

<!-- === 4-digit code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>


<!-- === matrix size === -->
<label>Matrix W <input id=matrixW type=number value=6 min=2 max=12 style="width:50px"></label>
<label>Matrix H <input id=matrixH type=number value=6 min=2 max=12 style="width:50px"></label><br>

<label>Pattern mode
  <select id=patternMode>
    <option value="vertical">Vertical symmetry</option>
    <option value="horizontal">Horizontal symmetry</option>
    <option value="both" selected>Both (H + V)</option>
  </select>
</label><br>


<!-- === creativity === -->
<label>Cell size (% of panel)
  <input id=cellSize type=range min=15 max=40 step=1 value=30>
</label><br>

<label>Display mode
  <select id=displayMode>
    <option value="both" selected>Color + Digit</option>
    <option value="color">Color only</option>
    <option value="digit">Digit only</option>
  </select>
</label><br>

<label><input id=showAxis type=checkbox checked> Show symmetry axis</label>
<label>Axis length
  <input id=axisLength type=range min=10 max=100 step=5 value=40>
</label><br>

<label>Axis style
  <select id=axisStyle>
    <option value="solid">Solid line</option>
    <option value="dashed" selected>Dashed line</option>
    <option value="gradient">Gradient fade</option>
  </select>
</label><br>

<label>Panel spacing
  <input id=panelSpacing type=range min=10 max=60 step=2 value=30>
</label><br>

<label>Grid border
  <input id=gridBorder type=range min=0 max=5 step=0.5 value=2>
</label><br>

<label>Cell border style
  <select id=borderStyle>
    <option value="solid" selected>Solid</option>
    <option value="double">Double</option>
    <option value="thin">Thin</option>
    <option value="none">None</option>
  </select>
</label><br>


<label>Frame style
  <select id=frameStyle>
    <option value="none" selected>None</option>
    <option value="thick">Thick</option>
    <option value="double">Double</option>
    <option value="rounded">Rounded</option>
    <option value="shadow">Shadow</option>
    <option value="rainbow">Rainbow</option>
  </select>
</label>
<label>Frame thickness
  <input id=frameThickness type=range min=1 max=15 step=1 value=4>
</label><br>


<label>Legend size (% of height)
  <input id=legendSize type=range min=3 max=10 step=0.5 value=6>
</label><br>

<label>Legend position
  <select id=legendPosition>
    <option value="top" selected>Top</option>
    <option value="bottom">Bottom</option>
    <option value="left">Left</option>
  </select>
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>
<button id=newPattern type=button>ðŸ”€ New patterns (same code)</button>


<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
// Color definitions for digit-to-color mapping puzzles
const DIGIT_COLORS = [
  { index: 0, hex: '#d40808', name: 'Red' },
  { index: 1, hex: '#0D47A1', name: 'Blue' },
  { index: 2, hex: '#43A047', name: 'Green' },
  { index: 3, hex: '#FDD835', name: 'Yellow' },
  { index: 4, hex: '#FB8C00', name: 'Orange' },
  { index: 5, hex: '#75118f', name: 'Purple' },
  { index: 6, hex: '#00CED1', name: 'Aqua' },
  { index: 7, hex: '#ff19d1', name: 'Pink' },
  { index: 8, hex: '#6D4C41', name: 'Brown' },
  { index: 9, hex: '#616161', name: 'Dark Grey' },
];
const DIGIT_COLOR_HEX = DIGIT_COLORS.map(c => c.hex);
const BASIC_COLORS = [
  { hex: '#FF0000', name: 'Red' },
  { hex: '#0000FF', name: 'Blue' },
  { hex: '#00AA00', name: 'Green' },
  { hex: '#FFCC00', name: 'Yellow' },
  { hex: '#FF00FF', name: 'Purple' },
];
const BASIC_COLOR_HEX = BASIC_COLORS.map(c => c.hex);
const COLORS = DIGIT_COLORS;
const COLOR_HEX = DIGIT_COLOR_HEX;

// Shuffled mapping: shuffledColorHex[digit] = color hex
let shuffledColorHex = [...COLOR_HEX];

function shuffleColorMap() {
  shuffledColorHex = [...COLOR_HEX];
  for (let i = shuffledColorHex.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledColorHex[i], shuffledColorHex[j]] = [shuffledColorHex[j], shuffledColorHex[i]];
  }
}
</script>
<script>
const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'pattern_grid_mirror';

const DEF = {
  w: 1200, h: 400, code: '1234',
  matrixW: 6, matrixH: 6, patternMode: 'both',
  cellSize: 30, displayMode: 'both', showAxis: true,
  axisLength: 40, axisStyle: 'dashed', panelSpacing: 30, gridBorder: 2,
  borderStyle: 'solid',
  frameStyle: 'none', frameThickness: 4,
  legendSize: 6, legendPosition: 'top'
};

// Store generated grids
let grids = [];

function generateGrid(answerDigit, cols, rows, mode) {
  const grid = [];

  // Initialize grid with random values
  for (let r = 0; r < rows; r++) {
    grid.push([]);
    for (let c = 0; c < cols; c++) {
      grid[r].push(Math.floor(Math.random() * 10));
    }
  }

  // Apply symmetry based on mode
  if (mode === 'vertical' || mode === 'both') {
    // Mirror left to right
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < Math.floor(cols / 2); c++) {
        grid[r][cols - 1 - c] = grid[r][c];
      }
    }
  }

  if (mode === 'horizontal' || mode === 'both') {
    // Mirror top to bottom
    for (let r = 0; r < Math.floor(rows / 2); r++) {
      for (let c = 0; c < cols; c++) {
        grid[rows - 1 - r][c] = grid[r][c];
      }
    }
  }

  // Find valid positions for the question mark (positions that have a mirror)
  const validPositions = [];

  if (mode === 'vertical') {
    // Question can be in left or right half (not center column if odd)
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < Math.floor(cols / 2); c++) {
        validPositions.push({ r, c, mirrorR: r, mirrorC: cols - 1 - c });
      }
      for (let c = Math.ceil(cols / 2); c < cols; c++) {
        validPositions.push({ r, c, mirrorR: r, mirrorC: cols - 1 - c });
      }
    }
  } else if (mode === 'horizontal') {
    // Question can be in top or bottom half (not center row if odd)
    for (let r = 0; r < Math.floor(rows / 2); r++) {
      for (let c = 0; c < cols; c++) {
        validPositions.push({ r, c, mirrorR: rows - 1 - r, mirrorC: c });
      }
    }
    for (let r = Math.ceil(rows / 2); r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        validPositions.push({ r, c, mirrorR: rows - 1 - r, mirrorC: c });
      }
    }
  } else {
    // Both: question can be anywhere except center row/column axes
    for (let r = 0; r < rows; r++) {
      if (rows % 2 === 1 && r === Math.floor(rows / 2)) continue; // skip center row
      for (let c = 0; c < cols; c++) {
        if (cols % 2 === 1 && c === Math.floor(cols / 2)) continue; // skip center col
        // Pick one mirror (vertical mirror for simplicity)
        validPositions.push({ r, c, mirrorR: r, mirrorC: cols - 1 - c });
      }
    }
  }

  // Pick random position for question
  const pos = validPositions[Math.floor(Math.random() * validPositions.length)];
  const { r: questionRow, c: questionCol } = pos;

  // Set answer digit in all symmetric positions to maintain symmetry
  grid[questionRow][questionCol] = answerDigit;

  if (mode === 'vertical' || mode === 'both') {
    grid[questionRow][cols - 1 - questionCol] = answerDigit;
  }
  if (mode === 'horizontal' || mode === 'both') {
    grid[rows - 1 - questionRow][questionCol] = answerDigit;
  }
  if (mode === 'both') {
    // Also set the diagonal mirror (opposite corner)
    grid[rows - 1 - questionRow][cols - 1 - questionCol] = answerDigit;
  }

  return { grid, questionRow, questionCol, answerDigit, cols, rows };
}

function regenerateGrids() {
  shuffleColorMap();
  const codeStr = $('code').value || '1234';
  const digits = codeStr.split('').map(Number);
  const cols = +$('matrixW').value || 6;
  const rows = +$('matrixH').value || 6;
  const mode = $('patternMode').value;
  grids = digits.map(d => generateGrid(d, cols, rows, mode));
}

function drawRoundedRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

function drawLegendHorizontal(x, y, availW, legendCircleR) {
  const legendSquareSize = legendCircleR * 2;
  const legendStartX = x + availW * 0.02;
  const legendEndX = x + availW * 0.98;
  const legendSpacing = (legendEndX - legendStartX) / 10;

  ctx.font = `bold ${legendCircleR * 1.2}px system-ui, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < 10; i++) {
    const cx = legendStartX + legendSpacing * i + legendSpacing / 2;

    ctx.fillStyle = shuffledColorHex[i];
    ctx.fillRect(cx - legendSquareSize / 2, y - legendSquareSize / 2, legendSquareSize, legendSquareSize);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.strokeRect(cx - legendSquareSize / 2, y - legendSquareSize / 2, legendSquareSize, legendSquareSize);

    ctx.fillStyle = '#333';
    ctx.fillText(i.toString(), cx, y + legendSquareSize / 2 + legendCircleR * 0.8);
  }
}

function drawLegendVertical(x, y, availH, legendCircleR) {
  const legendSquareSize = legendCircleR * 2;
  const entryHeight = availH / 10;

  ctx.font = `bold ${legendCircleR * 1.0}px system-ui, sans-serif`;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < 10; i++) {
    const cy = y + entryHeight * i + entryHeight / 2;

    ctx.fillStyle = shuffledColorHex[i];
    ctx.fillRect(x, cy - legendSquareSize / 2, legendSquareSize, legendSquareSize);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, cy - legendSquareSize / 2, legendSquareSize, legendSquareSize);

    ctx.fillStyle = '#333';
    ctx.fillText(i.toString(), x + legendSquareSize + legendCircleR * 0.4, cy);
  }
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  if (grids.length === 0) regenerateGrids();

  const legendSizePct = +$('legendSize').value / 100;
  const legendCircleR = H * legendSizePct / 2;
  const legendPosition = $('legendPosition').value;
  const displayMode = $('displayMode').value;
  const frameStyle = $('frameStyle').value;
  const frameThickness = +$('frameThickness').value;
  const cellBorderStyle = $('borderStyle').value;

  // Auto-hide legend when display mode includes digits (only show for "color only")
  const showLegend = displayMode === 'color';

  // Compute legend and grid areas based on legendPosition
  const legendBand = legendCircleR * 5;
  let gridAreaLeft, gridAreaTop, gridAreaWidth, gridAreaHeight;

  if (showLegend && legendPosition === 'top') {
    const legendY = legendCircleR * 1.5;
    drawLegendHorizontal(0, legendY, W, legendCircleR);
    const separatorY = legendY + legendCircleR * 2.8;
    ctx.beginPath();
    ctx.moveTo(W * 0.02, separatorY);
    ctx.lineTo(W * 0.98, separatorY);
    ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.stroke();
    gridAreaLeft = 0; gridAreaTop = separatorY + 10;
    gridAreaWidth = W; gridAreaHeight = H - gridAreaTop - 10;
  } else if (showLegend && legendPosition === 'bottom') {
    gridAreaLeft = 0; gridAreaTop = 10;
    const legendTop = H - legendBand;
    gridAreaHeight = legendTop - gridAreaTop - 10;
    gridAreaWidth = W;
    const separatorY = legendTop - 5;
    ctx.beginPath();
    ctx.moveTo(W * 0.02, separatorY);
    ctx.lineTo(W * 0.98, separatorY);
    ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.stroke();
    const legendY = legendTop + legendCircleR * 1.5;
    drawLegendHorizontal(0, legendY, W, legendCircleR);
  } else if (showLegend && legendPosition === 'left') {
    const legendW = legendCircleR * 5;
    drawLegendVertical(legendCircleR * 0.5, 10, H - 20, legendCircleR);
    const separatorX = legendW;
    ctx.beginPath();
    ctx.moveTo(separatorX, H * 0.02);
    ctx.lineTo(separatorX, H * 0.98);
    ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.stroke();
    gridAreaLeft = separatorX + 10; gridAreaTop = 10;
    gridAreaWidth = W - gridAreaLeft - 10; gridAreaHeight = H - 20;
  } else {
    // Legend hidden (auto-hide or no legend needed)
    gridAreaLeft = 10; gridAreaTop = 10;
    gridAreaWidth = W - 20; gridAreaHeight = H - 20;
  }

  // Draw grids
  const numPanels = grids.length;
  const panelSpacing = +$('panelSpacing').value;
  const totalPanelWidth = gridAreaWidth - 40;
  const panelWidth = (totalPanelWidth - (numPanels - 1) * panelSpacing) / numPanels;
  const cellSizePct = +$('cellSize').value / 100;
  const borderWidth = +$('gridBorder').value;
  const showAxis = $('showAxis').checked;
  const axisStyle = $('axisStyle').value;
  const patternMode = $('patternMode').value;

  for (let p = 0; p < numPanels; p++) {
    const { grid, questionRow, questionCol, answerDigit, cols, rows } = grids[p];
    const panelX = gridAreaLeft + 20 + p * (panelWidth + panelSpacing);
    const panelCenterX = panelX + panelWidth / 2;

    // Calculate cell size based on grid dimensions
    const maxCellW = panelWidth * cellSizePct / cols * 3;
    const maxCellH = gridAreaHeight * cellSizePct / rows * 3;
    const cellSize = Math.min(maxCellW, maxCellH);
    const gridWidth = cellSize * cols;
    const gridHeight = cellSize * rows;

    const gridLeft = panelCenterX - gridWidth / 2;
    const gridTop = gridAreaTop + (gridAreaHeight - gridHeight) / 2;

    // Draw axis lines behind grid
    if (showAxis) {
      ctx.save();
      const axisExt = +$('axisLength').value;

      const drawAxisLine = (x1, y1, x2, y2, isVertical) => {
        if (axisStyle === 'solid') {
          ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
          ctx.lineWidth = 2;
          ctx.setLineDash([]);
        } else if (axisStyle === 'dashed') {
          ctx.strokeStyle = 'rgba(100, 100, 100, 0.4)';
          ctx.lineWidth = 2;
          ctx.setLineDash([8, 4]);
        } else if (axisStyle === 'gradient') {
          let grad;
          if (isVertical) {
            grad = ctx.createLinearGradient(x1 - 20, 0, x1 + 20, 0);
          } else {
            grad = ctx.createLinearGradient(0, y1 - 20, 0, y1 + 20);
          }
          grad.addColorStop(0, 'rgba(100, 100, 100, 0)');
          grad.addColorStop(0.5, 'rgba(100, 100, 100, 0.3)');
          grad.addColorStop(1, 'rgba(100, 100, 100, 0)');
          ctx.strokeStyle = grad;
          ctx.lineWidth = 40;
          ctx.setLineDash([]);
        }
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      };

      if (patternMode === 'vertical' || patternMode === 'both') {
        const axisX = gridLeft + gridWidth / 2;
        drawAxisLine(axisX, gridTop - axisExt, axisX, gridTop + gridHeight + axisExt, true);
      }

      if (patternMode === 'horizontal' || patternMode === 'both') {
        const axisY = gridTop + gridHeight / 2;
        drawAxisLine(gridLeft - axisExt, axisY, gridLeft + gridWidth + axisExt, axisY, false);
      }

      ctx.restore();
    }

    // Draw grid cells
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const x = gridLeft + col * cellSize;
        const y = gridTop + row * cellSize;
        const value = grid[row][col];
        const isQuestion = row === questionRow && col === questionCol;

        // Cell background
        if (isQuestion) {
          ctx.fillStyle = '#fff';
        } else if (displayMode !== 'digit') {
          ctx.fillStyle = shuffledColorHex[value];
        } else {
          ctx.fillStyle = '#f5f5f5';
        }
        ctx.fillRect(x, y, cellSize, cellSize);

        // Cell border
        if (cellBorderStyle === 'solid') {
          ctx.strokeStyle = '#333';
          ctx.lineWidth = borderWidth;
          ctx.strokeRect(x, y, cellSize, cellSize);
        } else if (cellBorderStyle === 'double') {
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(0.5, borderWidth * 0.5);
          ctx.strokeRect(x, y, cellSize, cellSize);
          const inset = 2;
          ctx.strokeRect(x + inset, y + inset, cellSize - inset * 2, cellSize - inset * 2);
        } else if (cellBorderStyle === 'thin') {
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 0.5;
          ctx.strokeRect(x, y, cellSize, cellSize);
        }
        // 'none': no internal borders

        // Cell content
        const centerX = x + cellSize / 2;
        const centerY = y + cellSize / 2;
        const fontSize = cellSize * 0.5;
        ctx.font = `bold ${fontSize}px system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (isQuestion) {
          ctx.fillStyle = '#666';
          ctx.fillText('?', centerX, centerY);
        } else if (displayMode === 'both') {
          ctx.fillStyle = '#fff';
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1;
          ctx.strokeText(value.toString(), centerX, centerY);
          ctx.fillText(value.toString(), centerX, centerY);
        } else if (displayMode === 'digit') {
          ctx.fillStyle = '#333';
          ctx.fillText(value.toString(), centerX, centerY);
        }
      }
    }

    // For 'none' border style, draw only the outer grid border
    if (cellBorderStyle === 'none' && borderWidth > 0) {
      ctx.strokeStyle = '#333';
      ctx.lineWidth = borderWidth;
      ctx.strokeRect(gridLeft, gridTop, gridWidth, gridHeight);
    }

    // Frame decoration
    if (frameStyle !== 'none') {
      const pad = frameThickness;
      const fx = gridLeft - pad;
      const fy = gridTop - pad;
      const fw = gridWidth + pad * 2;
      const fh = gridHeight + pad * 2;

      ctx.save();
      if (frameStyle === 'thick') {
        ctx.strokeStyle = '#333';
        ctx.lineWidth = frameThickness;
        ctx.strokeRect(fx, fy, fw, fh);
      } else if (frameStyle === 'double') {
        const gap = Math.max(2, frameThickness * 0.6);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = Math.max(1, frameThickness * 0.4);
        ctx.strokeRect(fx, fy, fw, fh);
        ctx.strokeRect(fx - gap, fy - gap, fw + gap * 2, fh + gap * 2);
      } else if (frameStyle === 'rounded') {
        const radius = Math.max(4, frameThickness * 2);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = frameThickness;
        drawRoundedRect(fx, fy, fw, fh, radius);
        ctx.stroke();
      } else if (frameStyle === 'shadow') {
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        ctx.shadowBlur = frameThickness * 2;
        ctx.shadowOffsetX = frameThickness * 0.5;
        ctx.shadowOffsetY = frameThickness * 0.5;
        ctx.strokeStyle = '#333';
        ctx.lineWidth = Math.max(1, frameThickness * 0.5);
        ctx.strokeRect(fx, fy, fw, fh);
      } else if (frameStyle === 'rainbow') {
        const rainbowColors = ['#FF0000','#FF7F00','#FFFF00','#00FF00','#0000FF','#4B0082','#9400D3'];
        const stripW = frameThickness / rainbowColors.length;
        for (let s = 0; s < rainbowColors.length; s++) {
          const offset = s * stripW;
          ctx.strokeStyle = rainbowColors[s];
          ctx.lineWidth = Math.max(1, stripW);
          ctx.strokeRect(fx - offset, fy - offset, fw + offset * 2, fh + offset * 2);
        }
      }
      ctx.restore();
    }
  }
}

// Event handlers
function randCode() {
  const len = Math.min(5, Math.max(1, ($('code').value || '').length || 4));
  const max = Math.pow(10, len);
  $('code').value = (Math.random() * max | 0).toString().padStart(len, '0');
  regenerateGrids();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => { if (b.dataset.t === 'code') { randCode(); draw(); } };
});

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    if (el.type === 'checkbox') el.checked = DEF[k];
    else el.value = DEF[k];
  }
  regenerateGrids();
  draw();
};

$('newPattern').onclick = () => {
  regenerateGrids();
  draw();
};

$('code').oninput = () => { regenerateGrids(); draw(); };
$('matrixW').onchange = () => { regenerateGrids(); draw(); };
$('matrixH').onchange = () => { regenerateGrids(); draw(); };
$('patternMode').onchange = () => { regenerateGrids(); draw(); };

document.querySelectorAll('input, select').forEach(el => {
  if (!el.oninput) el.oninput = draw;
  if (!el.onchange) el.onchange = draw;
});

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};

// Range value displays
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:1px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});

// Initial
regenerateGrids();
draw();
</script>
