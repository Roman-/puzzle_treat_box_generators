<!doctype html>
<meta charset="utf-8">
<title>Outlined Digits Filter â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=300 min=100></label>

<!-- === 4-digit code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === rule settings === -->
<label>Rule Type
  <select id=ruleType>
    <option value="color" selected>Color-based</option>
    <option value="math">Math-based</option>
  </select>
</label><br>

<label>Current Rule: <strong id=currentRuleDisplay>â€”</strong></label>
<button id=newRule type=button>ðŸ”€ New Rule</button><br>

<hr>

<!-- === visual settings === -->

<label>Digit Font Family
  <select id=fontFamily>
    <option value="system-ui, -apple-system, sans-serif" selected>System Sans</option>
    <option value="Georgia, 'Times New Roman', serif">Serif</option>
    <option value="'Courier New', Courier, monospace">Monospace</option>
    <option value="'Comic Sans MS', cursive">Cursive</option>
  </select>
</label><br>

<label>Digit Style
  <select id=digitStyle>
    <option value="outlined" selected>Outlined</option>
    <option value="filled">Filled</option>
    <option value="filled-outline">Filled + Outline</option>
  </select>
</label><br>

<label><input type=checkbox id=shadowEnabled> Digit shadow</label><br>
<label>Shadow blur <input id=shadowBlur type=range min=0 max=20 step=1 value=5></label><br>
<label>Shadow offset X <input id=shadowOffsetX type=range min=-10 max=10 step=1 value=3></label><br>
<label>Shadow offset Y <input id=shadowOffsetY type=range min=-10 max=10 step=1 value=3></label><br>

<br>

<label>Digit size (% of height)
  <input id=digitSize type=range min=30 max=80 step=1 value=50>
</label><br>

<label>Outline thickness (% of digit)
  <input id=outlineThickness type=range min=3 max=20 step=1 value=8>
</label><br>

<label>Max rotation (&deg;)
  <input id=maxRotation type=range min=0 max=45 step=1 value=0>
</label><br>

<label>Total distractors
  <input id=distractors type=range min=2 max=12 step=1 value=6>
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
// Color definitions for digit-to-color mapping puzzles
const DIGIT_COLORS = [
  { index: 0, hex: '#d40808', name: 'Red' },
  { index: 1, hex: '#0D47A1', name: 'Blue' },
  { index: 2, hex: '#43A047', name: 'Green' },
  { index: 3, hex: '#FDD835', name: 'Yellow' },
  { index: 4, hex: '#FB8C00', name: 'Orange' },
  { index: 5, hex: '#75118f', name: 'Purple' },
  { index: 6, hex: '#00CED1', name: 'Aqua' },
  { index: 7, hex: '#ff19d1', name: 'Pink' },
  { index: 8, hex: '#6D4C41', name: 'Brown' },
  { index: 9, hex: '#616161', name: 'Dark Grey' },
];
const DIGIT_COLOR_HEX = DIGIT_COLORS.map(c => c.hex);
const BASIC_COLORS = [
  { hex: '#FF0000', name: 'Red' },
  { hex: '#0000FF', name: 'Blue' },
  { hex: '#00AA00', name: 'Green' },
  { hex: '#FFCC00', name: 'Yellow' },
  { hex: '#FF00FF', name: 'Purple' },
];
const BASIC_COLOR_HEX = BASIC_COLORS.map(c => c.hex);
const COLORS = DIGIT_COLORS;
const COLOR_HEX = DIGIT_COLOR_HEX;
</script>
<script>
// Display current value next to range inputs
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:1px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});
</script>
<script>

const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'outlined_digits_filter';

// Rule definitions
const RULES = {
  color: COLORS.map((c, i) => ({
    text: `Only ${c.name.toLowerCase()}`,
    colorIndex: i,
    check: (digit, colorIdx) => colorIdx === i,
    getMatchingDigits: () => [0,1,2,3,4,5,6,7,8,9], // any digit can match color
    needsColorMatch: true
  })),
  math: [
    {
      text: "Only even",
      check: d => d % 2 === 0,
      getMatchingDigits: () => [0, 2, 4, 6, 8]
    },
    {
      text: "Only odd",
      check: d => d % 2 === 1,
      getMatchingDigits: () => [1, 3, 5, 7, 9]
    },
    {
      text: "Only less than 5",
      check: d => d < 5,
      getMatchingDigits: () => [0, 1, 2, 3, 4]
    },
    {
      text: "Only 5 or more",
      check: d => d >= 5,
      getMatchingDigits: () => [5, 6, 7, 8, 9]
    }
  ]
};

// Defaults
const DEF = {
  w: 800, h: 300, code: '1234',
  ruleType: 'color', digitSize: 50,
  outlineThickness: 8, distractors: 6,
  fontFamily: 'system-ui, -apple-system, sans-serif',
  digitStyle: 'outlined',
  shadowEnabled: false,
  shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3,
  maxRotation: 0
};

// Current state
let currentRule = null;
let displaySequence = []; // { digit, colorIndex, isAnswer, rotation }

// Utility functions
const randomElement = arr => arr[Math.floor(Math.random() * arr.length)];
const shuffle = arr => {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};

function darkenHex(hex, percent) {
  hex = hex.replace('#', '');
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  const factor = 1 - percent / 100;
  return '#' + [r, g, b].map(c => Math.max(0, Math.round(c * factor)).toString(16).padStart(2, '0')).join('');
}

function selectNewRule() {
  let ruleType = $('ruleType').value;
  if (ruleType === 'random') {
    ruleType = randomElement(['color', 'shape', 'math']);
  }
  currentRule = randomElement(RULES[ruleType]);
  $('currentRuleDisplay').textContent = currentRule.text;
  regenerateCode();
}

function regenerateCode() {
  if (!currentRule) {
    selectNewRule();
    return;
  }

  const codeLength = Math.min(5, Math.max(1, ($('code').value || '').length || 4));
  const matchingDigits = currentRule.getMatchingDigits();

  if (matchingDigits.length === 0) {
    console.error('No matching digits for rule');
    return;
  }

  // Generate a code using only matching digits
  let newCode = '';
  for (let i = 0; i < codeLength; i++) {
    newCode += randomElement(matchingDigits);
  }
  $('code').value = newCode;

  generateDisplaySequence();
}

function generateDisplaySequence() {
  if (!currentRule) {
    selectNewRule();
    return;
  }

  const codeStr = $('code').value || '1234';
  const codeDigits = codeStr.split('').map(Number);
  const totalDistractors = +$('distractors').value;

  // Get non-matching digits for distractors
  const matchingSet = new Set(currentRule.getMatchingDigits());
  const distractorDigits = [0,1,2,3,4,5,6,7,8,9].filter(d => !matchingSet.has(d));

  // For color rules, all digits can be distractors (just with wrong color)
  const useAnyDigitAsDistractor = currentRule.needsColorMatch;

  const maxRot = +$('maxRotation').value;
  function randRotation() {
    return maxRot > 0 ? (Math.random() * 2 - 1) * maxRot : 0;
  }

  // Create answer entries
  const answerEntries = codeDigits.map(codeDigit => {
    let codeColor;
    if (currentRule.needsColorMatch) {
      codeColor = currentRule.colorIndex;
    } else {
      codeColor = Math.floor(Math.random() * 10);
    }
    return {
      digit: codeDigit,
      colorIndex: codeColor,
      isAnswer: true,
      rotation: randRotation()
    };
  });

  // Create distractor entries
  const distractorEntries = [];
  for (let j = 0; j < totalDistractors; j++) {
    let distractorDigit;
    let distractorColor;

    if (useAnyDigitAsDistractor) {
      distractorDigit = Math.floor(Math.random() * 10);
      const otherColors = [0,1,2,3,4,5,6,7,8,9].filter(c => c !== currentRule.colorIndex);
      distractorColor = randomElement(otherColors);
    } else {
      if (distractorDigits.length > 0) {
        distractorDigit = randomElement(distractorDigits);
      } else {
        distractorDigit = Math.floor(Math.random() * 10);
      }
      distractorColor = Math.floor(Math.random() * 10);
    }

    distractorEntries.push({
      digit: distractorDigit,
      colorIndex: distractorColor,
      isAnswer: false,
      rotation: randRotation()
    });
  }

  // Randomly distribute distractors across all possible slots
  // Slots: before first answer, between answers, after last answer
  // This makes it unpredictable - first/last digit shown may not be an answer
  const numSlots = codeDigits.length + 1; // before, between each, and after
  const slotCounts = new Array(numSlots).fill(0);

  // Distribute each distractor to a random slot
  for (let i = 0; i < totalDistractors; i++) {
    const slotIndex = Math.floor(Math.random() * numSlots);
    slotCounts[slotIndex]++;
  }

  // Build final sequence: [distractors], answer, [distractors], answer, ... [distractors]
  displaySequence = [];
  let distractorIdx = 0;

  for (let i = 0; i < answerEntries.length; i++) {
    // Add distractors for slot before this answer
    for (let j = 0; j < slotCounts[i]; j++) {
      displaySequence.push(distractorEntries[distractorIdx++]);
    }
    displaySequence.push(answerEntries[i]);
  }

  // Add trailing distractors (last slot)
  for (let j = 0; j < slotCounts[numSlots - 1]; j++) {
    displaySequence.push(distractorEntries[distractorIdx++]);
  }
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;

  // Background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, W, H);

  if (!currentRule || displaySequence.length === 0) {
    generateDisplaySequence();
  }

  const digitSizePct = +$('digitSize').value / 100;
  const outlineThicknessPct = +$('outlineThickness').value / 100;
  const fontFamily = $('fontFamily').value;
  const digitStyle = $('digitStyle').value;
  const shadowOn = $('shadowEnabled').checked;

  // Layout calculations
  const ruleAreaHeight = H * 0.25;
  const digitAreaTop = ruleAreaHeight;
  const digitAreaHeight = H - ruleAreaHeight;

  const digitHeight = digitAreaHeight * digitSizePct;
  const outlineWidth = digitHeight * outlineThicknessPct;

  // Draw rule text
  ctx.fillStyle = '#333';
  ctx.font = `bold ${ruleAreaHeight * 0.5}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(currentRule.text, W / 2, ruleAreaHeight / 2);

  // Draw separator line
  ctx.beginPath();
  ctx.moveTo(W * 0.05, ruleAreaHeight - 10);
  ctx.lineTo(W * 0.95, ruleAreaHeight - 10);
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Calculate digit positions
  const numDigits = displaySequence.length;
  const digitSpacing = W / (numDigits + 1);
  const digitY = digitAreaTop + digitAreaHeight / 2;

  // Draw each digit
  ctx.font = `bold ${digitHeight}px ${fontFamily}`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < numDigits; i++) {
    const { digit, colorIndex, rotation } = displaySequence[i];
    const x = digitSpacing * (i + 1);
    const digitStr = digit.toString();
    const color = COLOR_HEX[colorIndex];

    ctx.save();
    ctx.translate(x, digitY);
    if (rotation) {
      ctx.rotate(rotation * Math.PI / 180);
    }

    // Apply shadow if enabled
    if (shadowOn) {
      ctx.shadowColor = 'rgba(0,0,0,0.4)';
      ctx.shadowBlur = +$('shadowBlur').value;
      ctx.shadowOffsetX = +$('shadowOffsetX').value;
      ctx.shadowOffsetY = +$('shadowOffsetY').value;
    }

    if (digitStyle === 'outlined') {
      // White fill + colored outline
      ctx.fillStyle = '#fff';
      ctx.lineWidth = outlineWidth + 4;
      ctx.strokeStyle = '#fff';
      ctx.strokeText(digitStr, 0, 0);
      ctx.fillText(digitStr, 0, 0);

      ctx.strokeStyle = color;
      ctx.lineWidth = outlineWidth;
      ctx.lineJoin = 'round';
      ctx.strokeText(digitStr, 0, 0);

      ctx.fillStyle = '#fff';
      ctx.fillText(digitStr, 0, 0);

    } else if (digitStyle === 'filled') {
      ctx.fillStyle = color;
      ctx.fillText(digitStr, 0, 0);

    } else if (digitStyle === 'filled-outline') {
      const darkerColor = darkenHex(color, 30);
      ctx.strokeStyle = darkerColor;
      ctx.lineWidth = outlineWidth;
      ctx.lineJoin = 'round';
      ctx.strokeText(digitStr, 0, 0);

      ctx.fillStyle = color;
      ctx.fillText(digitStr, 0, 0);
    }

    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    ctx.restore();
  }
}

// Event handlers
function randCode() {
  regenerateCode();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => {
    if (b.dataset.t === 'code') { randCode(); draw(); }
  };
});

$('newRule').onclick = () => {
  selectNewRule();
  draw();
};

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    if (el.type === 'checkbox') {
      el.checked = DEF[k];
    } else {
      el.value = DEF[k];
    }
  }
  document.querySelectorAll('input[type=range]').forEach(r => {
    const span = r.nextElementSibling;
    if (span && span.tagName === 'SPAN') span.textContent = r.value;
  });
  selectNewRule();
  draw();
};

// Input change handlers
$('code').oninput = () => {
  // Validate code against current rule
  const codeStr = $('code').value || '';
  const codeDigits = codeStr.split('').map(Number);
  const matchingDigits = new Set(currentRule ? currentRule.getMatchingDigits() : [0,1,2,3,4,5,6,7,8,9]);

  // Check if all code digits match the rule (for non-color rules)
  if (currentRule && !currentRule.needsColorMatch) {
    const allMatch = codeDigits.every(d => matchingDigits.has(d));
    if (!allMatch) {
      // Code doesn't match rule - regenerate appropriate code
      regenerateCode();
      return;
    }
  }

  generateDisplaySequence();
  draw();
};

$('ruleType').onchange = () => {
  selectNewRule();
  draw();
};

$('distractors').oninput = () => {
  generateDisplaySequence();
  draw();
};

$('fontFamily').onchange = draw;
$('digitStyle').onchange = draw;
$('shadowEnabled').onchange = draw;
$('shadowBlur').oninput = draw;
$('shadowOffsetX').oninput = draw;
$('shadowOffsetY').oninput = draw;

$('maxRotation').oninput = () => {
  generateDisplaySequence();
  draw();
};

document.querySelectorAll('input[type=range]').forEach(el => {
  if (!['distractors', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'maxRotation'].includes(el.id)) {
    el.oninput = draw;
  }
});

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  // Generate new puzzle after download
  randCode();
  draw();
};

// Initial setup
selectNewRule();
draw();

</script>
