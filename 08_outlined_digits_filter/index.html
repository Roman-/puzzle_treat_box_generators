<!doctype html>
<meta charset="utf-8">
<title>Outlined Digits Filter â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=300 min=100></label>

<!-- === 4-digit code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === rule settings === -->
<label>Rule Type
  <select id=ruleType>
    <option value="color" selected>Color-based</option>
    <option value="math">Math-based</option>
  </select>
</label><br>

<label>Current Rule: <strong id=currentRuleDisplay>â€”</strong></label>
<button id=newRule type=button>ðŸ”€ New Rule</button><br>

<hr>

<!-- === visual settings === -->
<label>Digit size (% of height)
  <input id=digitSize type=range min=30 max=80 step=1 value=50>
</label><br>

<label>Outline thickness (% of digit)
  <input id=outlineThickness type=range min=3 max=20 step=1 value=8>
</label><br>

<label>Total distractors
  <input id=distractors type=range min=2 max=12 step=1 value=6>
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
// Color definitions for digit-to-color mapping puzzles
const DIGIT_COLORS = [
  { index: 0, hex: '#d40808', name: 'Red' },
  { index: 1, hex: '#0D47A1', name: 'Blue' },
  { index: 2, hex: '#43A047', name: 'Green' },
  { index: 3, hex: '#FDD835', name: 'Yellow' },
  { index: 4, hex: '#FB8C00', name: 'Orange' },
  { index: 5, hex: '#75118f', name: 'Purple' },
  { index: 6, hex: '#00CED1', name: 'Aqua' },
  { index: 7, hex: '#ff19d1', name: 'Pink' },
  { index: 8, hex: '#6D4C41', name: 'Brown' },
  { index: 9, hex: '#616161', name: 'Dark Grey' },
];
const DIGIT_COLOR_HEX = DIGIT_COLORS.map(c => c.hex);
const BASIC_COLORS = [
  { hex: '#FF0000', name: 'Red' },
  { hex: '#0000FF', name: 'Blue' },
  { hex: '#00AA00', name: 'Green' },
  { hex: '#FFCC00', name: 'Yellow' },
  { hex: '#FF00FF', name: 'Purple' },
];
const BASIC_COLOR_HEX = BASIC_COLORS.map(c => c.hex);
const COLORS = DIGIT_COLORS;
const COLOR_HEX = DIGIT_COLOR_HEX;
</script>
<script>
// Display current value next to range inputs
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:1px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});
</script>
<script>

const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'outlined_digits_filter';

// Rule definitions
const RULES = {
  color: COLORS.map((c, i) => ({
    text: `Only ${c.name.toLowerCase()}`,
    colorIndex: i,
    check: (digit, colorIdx) => colorIdx === i,
    getMatchingDigits: () => [0,1,2,3,4,5,6,7,8,9], // any digit can match color
    needsColorMatch: true
  })),
  math: [
    {
      text: "Only even",
      check: d => d % 2 === 0,
      getMatchingDigits: () => [0, 2, 4, 6, 8]
    },
    {
      text: "Only odd",
      check: d => d % 2 === 1,
      getMatchingDigits: () => [1, 3, 5, 7, 9]
    },
    {
      text: "Only less than 5",
      check: d => d < 5,
      getMatchingDigits: () => [0, 1, 2, 3, 4]
    },
    {
      text: "Only 5 or more",
      check: d => d >= 5,
      getMatchingDigits: () => [5, 6, 7, 8, 9]
    }
  ]
};

// Defaults
const DEF = {
  w: 800, h: 300, code: '1234',
  ruleType: 'color', digitSize: 50,
  outlineThickness: 8, distractors: 6
};

// Current state
let currentRule = null;
let displaySequence = []; // { digit, colorIndex, isAnswer }

// Utility functions
const randomElement = arr => arr[Math.floor(Math.random() * arr.length)];
const shuffle = arr => {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};

function selectNewRule() {
  let ruleType = $('ruleType').value;
  if (ruleType === 'random') {
    ruleType = randomElement(['color', 'shape', 'math']);
  }
  currentRule = randomElement(RULES[ruleType]);
  $('currentRuleDisplay').textContent = currentRule.text;
  regenerateCode();
}

function regenerateCode() {
  if (!currentRule) {
    selectNewRule();
    return;
  }

  const codeLength = Math.min(5, Math.max(1, ($('code').value || '').length || 4));
  const matchingDigits = currentRule.getMatchingDigits();

  if (matchingDigits.length === 0) {
    console.error('No matching digits for rule');
    return;
  }

  // Generate a code using only matching digits
  let newCode = '';
  for (let i = 0; i < codeLength; i++) {
    newCode += randomElement(matchingDigits);
  }
  $('code').value = newCode;

  generateDisplaySequence();
}

function generateDisplaySequence() {
  if (!currentRule) {
    selectNewRule();
    return;
  }

  const codeStr = $('code').value || '1234';
  const codeDigits = codeStr.split('').map(Number);
  const totalDistractors = +$('distractors').value;

  // Get non-matching digits for distractors
  const matchingSet = new Set(currentRule.getMatchingDigits());
  const distractorDigits = [0,1,2,3,4,5,6,7,8,9].filter(d => !matchingSet.has(d));

  // For color rules, all digits can be distractors (just with wrong color)
  const useAnyDigitAsDistractor = currentRule.needsColorMatch;

  // Create answer entries
  const answerEntries = codeDigits.map(codeDigit => {
    let codeColor;
    if (currentRule.needsColorMatch) {
      codeColor = currentRule.colorIndex;
    } else {
      codeColor = Math.floor(Math.random() * 10);
    }
    return {
      digit: codeDigit,
      colorIndex: codeColor,
      isAnswer: true
    };
  });

  // Create distractor entries
  const distractorEntries = [];
  for (let j = 0; j < totalDistractors; j++) {
    let distractorDigit;
    let distractorColor;

    if (useAnyDigitAsDistractor) {
      distractorDigit = Math.floor(Math.random() * 10);
      const otherColors = [0,1,2,3,4,5,6,7,8,9].filter(c => c !== currentRule.colorIndex);
      distractorColor = randomElement(otherColors);
    } else {
      if (distractorDigits.length > 0) {
        distractorDigit = randomElement(distractorDigits);
      } else {
        distractorDigit = Math.floor(Math.random() * 10);
      }
      distractorColor = Math.floor(Math.random() * 10);
    }

    distractorEntries.push({
      digit: distractorDigit,
      colorIndex: distractorColor,
      isAnswer: false
    });
  }

  // Randomly distribute distractors across all possible slots
  // Slots: before first answer, between answers, after last answer
  // This makes it unpredictable - first/last digit shown may not be an answer
  const numSlots = codeDigits.length + 1; // before, between each, and after
  const slotCounts = new Array(numSlots).fill(0);

  // Distribute each distractor to a random slot
  for (let i = 0; i < totalDistractors; i++) {
    const slotIndex = Math.floor(Math.random() * numSlots);
    slotCounts[slotIndex]++;
  }

  // Build final sequence: [distractors], answer, [distractors], answer, ... [distractors]
  displaySequence = [];
  let distractorIdx = 0;

  for (let i = 0; i < answerEntries.length; i++) {
    // Add distractors for slot before this answer
    for (let j = 0; j < slotCounts[i]; j++) {
      displaySequence.push(distractorEntries[distractorIdx++]);
    }
    displaySequence.push(answerEntries[i]);
  }

  // Add trailing distractors (last slot)
  for (let j = 0; j < slotCounts[numSlots - 1]; j++) {
    displaySequence.push(distractorEntries[distractorIdx++]);
  }
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;

  // Background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, W, H);

  if (!currentRule || displaySequence.length === 0) {
    generateDisplaySequence();
  }

  const digitSizePct = +$('digitSize').value / 100;
  const outlineThicknessPct = +$('outlineThickness').value / 100;

  // Layout calculations
  const ruleAreaHeight = H * 0.25;
  const digitAreaTop = ruleAreaHeight;
  const digitAreaHeight = H - ruleAreaHeight;

  const digitHeight = digitAreaHeight * digitSizePct;
  const outlineWidth = digitHeight * outlineThicknessPct;

  // Draw rule text
  ctx.fillStyle = '#333';
  ctx.font = `bold ${ruleAreaHeight * 0.5}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(currentRule.text, W / 2, ruleAreaHeight / 2);

  // Draw separator line
  ctx.beginPath();
  ctx.moveTo(W * 0.05, ruleAreaHeight - 10);
  ctx.lineTo(W * 0.95, ruleAreaHeight - 10);
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Calculate digit positions
  const numDigits = displaySequence.length;
  const digitSpacing = W / (numDigits + 1);
  const digitY = digitAreaTop + digitAreaHeight / 2;

  // Draw each digit
  ctx.font = `bold ${digitHeight}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < numDigits; i++) {
    const { digit, colorIndex } = displaySequence[i];
    const x = digitSpacing * (i + 1);

    // Draw white fill first (background for the digit)
    ctx.fillStyle = '#fff';
    ctx.lineWidth = outlineWidth + 4;
    ctx.strokeStyle = '#fff';
    ctx.strokeText(digit.toString(), x, digitY);
    ctx.fillText(digit.toString(), x, digitY);

    // Draw colored outline
    ctx.strokeStyle = COLOR_HEX[colorIndex];
    ctx.lineWidth = outlineWidth;
    ctx.lineJoin = 'round';
    ctx.strokeText(digit.toString(), x, digitY);

    // Draw the digit fill (white) on top
    ctx.fillStyle = '#fff';
    ctx.fillText(digit.toString(), x, digitY);
  }
}

// Event handlers
function randCode() {
  regenerateCode();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => {
    if (b.dataset.t === 'code') { randCode(); draw(); }
  };
});

$('newRule').onclick = () => {
  selectNewRule();
  draw();
};

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    el.value = DEF[k];
  }
  selectNewRule();
  draw();
};

// Input change handlers
$('code').oninput = () => {
  // Validate code against current rule
  const codeStr = $('code').value || '';
  const codeDigits = codeStr.split('').map(Number);
  const matchingDigits = new Set(currentRule ? currentRule.getMatchingDigits() : [0,1,2,3,4,5,6,7,8,9]);

  // Check if all code digits match the rule (for non-color rules)
  if (currentRule && !currentRule.needsColorMatch) {
    const allMatch = codeDigits.every(d => matchingDigits.has(d));
    if (!allMatch) {
      // Code doesn't match rule - regenerate appropriate code
      regenerateCode();
      return;
    }
  }

  generateDisplaySequence();
  draw();
};

$('ruleType').onchange = () => {
  selectNewRule();
  draw();
};

$('distractors').oninput = () => {
  generateDisplaySequence();
  draw();
};

document.querySelectorAll('input[type=range]').forEach(el => {
  if (el.id !== 'distractors') {
    el.oninput = draw;
  }
});

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  // Generate new puzzle after download
  randCode();
  draw();
};

// Initial setup
selectNewRule();
draw();

</script>
