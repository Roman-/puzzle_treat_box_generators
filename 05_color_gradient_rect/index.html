<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Digit Color Encoder</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 1000px;
      margin: 20px auto;
    }

    label {
      display: inline-block;
      margin: 5px 10px 5px 0;
    }

    hr {
      margin: 20px 0;
      border: none;
      border-top: 1px solid #ccc;
    }

    canvas {
      border: 1px solid #999;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
      max-width: 100%;
    }

    .controls {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 8px;
    }

    .row {
      margin-bottom: 10px;
    }

    h1 {
      margin-top: 0;
    }

    button {
      cursor: pointer;
    }
  </style>
</head>

<body>
  <h1>Digit Color Encoder</h1>

  <div class="controls">
    <!-- === Dimensions === -->
    <div class="row">
      <label>Width <input id="w" type="number" value="800" min="100" step=10></label>
      <!-- Height is calculated dynamically based on content, but we can offer a base scale or just let it be auto -->
      <!-- The previous implementation calculated height. Let's stick to width control for now as height depends on legend/strap size. -->
    </div>

    <!-- === Puzzle Content === -->
    <div class="row">
      <label>Code (digits) <input id="digitsInput" type="text" value="4121" placeholder="e.g. 4121"></label>
      <button id="randomizeBtn" type="button">ðŸŽ² Random Code</button>
    </div>

    <hr>

    <!-- === Legend Appearance === -->
    <div class="row">
      <label>Digit Size <input id="digitSize" type="range" min="10" max="60" value="22"
          oninput="this.nextElementSibling.value = this.value"> <output>22</output>px</label>
      <label>Digit Offset <input id="digitOffset" type="range" min="-50" max="50" value="10"
          oninput="this.nextElementSibling.value = this.value"> <output>10</output>px</label>
      <label><input id="colorDigit" type="checkbox"> Color Digit</label>
    </div>

    <hr>

    <div class="row">
      <button id="downloadBtn" type="button">ðŸ’¾ Download PNG</button>
    </div>

    <div id="error" style="color: red; margin-top: 10px;"></div>
  </div>

  <br>
  <canvas id="canvas"></canvas>

  <script>
    (function () {
      const digitsInput = document.getElementById('digitsInput');
      const randomizeBtn = document.getElementById('randomizeBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const widthInput = document.getElementById('w');
      const digitSizeInput = document.getElementById('digitSize');
      const digitOffsetInput = document.getElementById('digitOffset');
      const colorDigitInput = document.getElementById('colorDigit');
      const errorEl = document.getElementById('error');
      const canvas = document.getElementById('canvas');

      let lastState = null;

      function showError(msg) {
        errorEl.textContent = msg || '';
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      // HSV (0â€“359, 0â€“1, 0â€“1) -> CSS rgb()
      function hsvToCss(h, s, v) {
        const c = v * s;
        const hh = h / 60;
        const x = c * (1 - Math.abs(hh % 2 - 1));
        let r1 = 0, g1 = 0, b1 = 0;

        if (hh >= 0 && hh < 1) {
          r1 = c; g1 = x; b1 = 0;
        } else if (hh >= 1 && hh < 2) {
          r1 = x; g1 = c; b1 = 0;
        } else if (hh >= 2 && hh < 3) {
          r1 = 0; g1 = c; b1 = x;
        } else if (hh >= 3 && hh < 4) {
          r1 = 0; g1 = x; b1 = c;
        } else if (hh >= 4 && hh < 5) {
          r1 = x; g1 = 0; b1 = c;
        } else {
          r1 = c; g1 = 0; b1 = x;
        }

        const m = v - c;
        const r = Math.round((r1 + m) * 255);
        const g = Math.round((g1 + m) * 255);
        const b = Math.round((b1 + m) * 255);
        return 'rgb(' + r + ',' + g + ',' + b + ')';
      }

      // Step 2: build sorted array of K >= N digits 0â€“9 containing all input digits
      function buildDigitSet(input) {
        const digits = input.split('').map(ch => parseInt(ch, 10));
        const unique = Array.from(new Set(digits)).sort((a, b) => a - b);
        const allDigits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        const remaining = allDigits.filter(d => !unique.includes(d));

        const N = input.length;
        const Kmin = Math.max(unique.length, N); // must be >= N and include all unique digits
        const Kmax = 10;

        const targetK = (Kmin === Kmax)
          ? Kmax
          : (Kmin + Math.floor(Math.random() * (Kmax - Kmin + 1)));

        shuffle(remaining);
        const extraNeeded = targetK - unique.length;
        const extra = remaining.slice(0, extraNeeded);

        const result = unique.concat(extra).sort((a, b) => a - b);
        return result;
      }

      // Step 3: assign HSV colors to each digit in digitSet
      function buildColorMap(digitSet) {
        const hueGap = 30;
        const usedHues = [];
        const s = 0.8 + Math.random() * 0.2; // 80â€“100%
        const v = 0.8 + Math.random() * 0.2; // 80â€“100%
        const map = new Map();

        for (const d of digitSet) {
          let hue = null;

          for (let attempt = 0; attempt < 80; attempt++) {
            const candidate = Math.floor(Math.random() * 360);
            const ok = usedHues.every(prev => {
              const diff = Math.abs(candidate - prev);
              const dist = Math.min(diff, 360 - diff);
              return dist >= hueGap;
            });
            if (ok || usedHues.length === 0) {
              hue = candidate;
              break;
            }
          }

          // Fallback: evenly spaced hues if random picking failed
          if (hue === null) {
            const step = 360 / digitSet.length;
            hue = (usedHues.length * step) % 360;
          }

          usedHues.push(hue);
          map.set(d, hsvToCss(hue, s, v));
        }

        return { map, s, v };
      }

      function clearCanvas() {
        const ctx = canvas.getContext('2d');
        const width = parseInt(widthInput.value, 10) || 800;
        canvas.width = width;
        // Keep height as is or reset? Let's just clear.
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      // Step 4 & 5: draw legend and encoding stripe
      function drawCanvas(state) {
        const { input, digitSet, colors, s, v } = state;
        const ctx = canvas.getContext('2d');

        const width = parseInt(widthInput.value, 10) || 800;
        const digitSize = parseInt(digitSizeInput.value, 10) || 22;
        const digitOffset = parseInt(digitOffsetInput.value, 10) || 10;
        const colorDigit = colorDigitInput.checked;

        canvas.width = width;

        const margin = 32;
        const legendCellHeight = 70;
        const legendTitleHeight = 24;
        const columns = Math.min(digitSet.length, 5);
        const rows = Math.ceil(digitSet.length / columns);
        const legendHeight = legendTitleHeight + rows * legendCellHeight;

        const strapHeight = 90;
        const strapTopMargin = 40;
        const strapBottomMargin = 20;
        const questionBlockHeight = 70;

        const totalHeight =
          margin +
          legendHeight +
          strapTopMargin +
          strapHeight +
          strapBottomMargin +
          questionBlockHeight;

        canvas.height = totalHeight;

        const ctx2 = canvas.getContext('2d');

        // Background
        ctx2.clearRect(0, 0, canvas.width, canvas.height);
        ctx2.fillStyle = '#ffffff';
        ctx2.fillRect(0, 0, canvas.width, canvas.height);

        // Legend title
        let y = margin;
        ctx2.font = '18px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx2.fillStyle = '#111827';
        ctx2.textAlign = 'left';
        ctx2.textBaseline = 'top';
        ctx2.fillText('Digit color legend', margin, y);
        y += legendTitleHeight;

        // Legend grid: digit + colored circle
        const gridWidth = width - margin * 2;
        const cellWidth = gridWidth / columns;
        const circleRadius = 16;

        digitSet.forEach((digit, index) => {
          const row = Math.floor(index / columns);
          const col = index % columns;
          const cellX = margin + col * cellWidth;
          const cellY = y + row * legendCellHeight;

          const cx = cellX + cellWidth / 2;
          const cy = cellY + legendCellHeight / 2;

          // Draw Circle
          ctx2.beginPath();
          ctx2.arc(cx, cy, circleRadius, 0, Math.PI * 2);
          ctx2.fillStyle = colors.get(digit);
          ctx2.fill();
          ctx2.lineWidth = 1;
          ctx2.strokeStyle = 'rgba(17, 24, 39, 0.2)';
          ctx2.stroke();

          // Draw Digit
          ctx2.font = `${digitSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
          ctx2.fillStyle = colorDigit ? colors.get(digit) : '#111827';
          ctx2.textAlign = 'center';
          ctx2.textBaseline = 'middle';

          // Offset relative to circle center. 
          // Positive offset -> to the right? Or below?
          // User said "near their circles". Let's assume X offset for side-by-side or Y for below?
          // "exactly underneath" was for question marks.
          // Let's interpret "Digit Offset" as X offset from circle center + radius.
          // Actually, let's just use X offset from center.
          // If offset is 0, it's on top of circle.
          // If offset is > radius, it's to the right.
          // Let's make it simple: X coordinate = cx + digitOffset.

          ctx2.fillText(String(digit), cx + digitOffset, cy);
        });

        const legendBottomY = y + rows * legendCellHeight;

        // Encoding stripe (wide rectangle)
        const strapX = margin;
        const strapY = legendBottomY + strapTopMargin;
        const strapWidth = width - margin * 2;

        // Left/right random boundary colors (same S,V as digit set)
        const leftHue = Math.floor(Math.random() * 360);
        let rightHue = null;
        for (let attempt = 0; attempt < 80; attempt++) {
          const candidate = Math.floor(Math.random() * 360);
          const diff = Math.abs(candidate - leftHue);
          const dist = Math.min(diff, 360 - diff);
          if (dist >= 45) {
            rightHue = candidate;
            break;
          }
        }
        if (rightHue === null) {
          rightHue = (leftHue + 180) % 360;
        }

        const leftColor = hsvToCss(leftHue, s, v);
        const rightColor = hsvToCss(rightHue, s, v);

        const gradient = ctx2.createLinearGradient(strapX, 0, strapX + strapWidth, 0);
        gradient.addColorStop(0, leftColor);

        // N points along the stripe, one per digit in input, in order
        const N = input.length;
        if (N > 0) {
          const step = 1 / (N + 1);

          for (let i = 0; i < N; i++) {
            const pos = (i + 1) * step; // in (0,1)
            const d = parseInt(input[i], 10);
            const color = colors.get(d);
            gradient.addColorStop(pos, color);
          }

          gradient.addColorStop(1, rightColor);

          // Fill stripe
          ctx2.fillStyle = gradient;
          ctx2.fillRect(strapX, strapY, strapWidth, strapHeight);

          // Border
          ctx2.lineWidth = 2;
          ctx2.strokeStyle = 'rgba(17, 24, 39, 0.2)';
          ctx2.strokeRect(strapX, strapY, strapWidth, strapHeight);

          // Markers and Question Marks
          const markerY = strapY + strapHeight / 2;
          const qY = strapY + strapHeight + strapBottomMargin;

          ctx2.textAlign = 'center';
          ctx2.textBaseline = 'top';
          ctx2.font = '32px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';

          for (let i = 0; i < N; i++) {
            const pos = (i + 1) * step;
            const x = strapX + strapWidth * pos;
            const d = parseInt(input[i], 10);
            const color = colors.get(d);

            // Marker on stripe
            ctx2.beginPath();
            ctx2.arc(x, markerY, 4.5, 0, Math.PI * 2);
            ctx2.fillStyle = color;
            ctx2.fill();
            ctx2.lineWidth = 1;
            ctx2.strokeStyle = 'rgba(255, 255, 255, 0.75)';
            ctx2.stroke();

            // Question mark below
            ctx2.fillStyle = '#111827';
            ctx2.fillText('?', x, qY);
          }

          // REMOVED: Caption "A number is encoded in this stripe"

        } else {
          // Just a simple left-right gradient if somehow N == 0
          gradient.addColorStop(1, rightColor);
          ctx2.fillStyle = gradient;
          ctx2.fillRect(strapX, strapY, strapWidth, strapHeight);
          ctx2.lineWidth = 2;
          ctx2.strokeStyle = 'rgba(17, 24, 39, 0.2)';
          ctx2.strokeRect(strapX, strapY, strapWidth, strapHeight);
        }
      }

      function handleGenerate() {
        const raw = digitsInput.value.trim();

        if (!raw) {
          showError('Please enter at least one digit.');
          clearCanvas();
          return;
        }
        if (!/^\d+$/.test(raw)) {
          showError('Use digits 0â€“9 only (no spaces or other characters).');
          clearCanvas();
          return;
        }
        if (raw.length > 10) {
          showError('Please enter at most 10 digits so the legend can fit (you entered ' + raw.length + ').');
          clearCanvas();
          return;
        }

        showError('');

        const digitSet = buildDigitSet(raw);
        const { map, s, v } = buildColorMap(digitSet);

        const state = {
          input: raw,
          digitSet,
          colors: map,
          s,
          v
        };

        lastState = state;
        drawCanvas(state);
      }

      // Event Listeners
      const inputs = [widthInput, digitSizeInput, digitOffsetInput, colorDigitInput];
      inputs.forEach(el => el.addEventListener('input', () => {
        if (lastState) drawCanvas(lastState);
      }));

      digitsInput.addEventListener('input', handleGenerate);

      randomizeBtn.addEventListener('click', () => {
        const len = Math.random() > 0.5 ? 4 : 5;
        let s = '';
        for (let i = 0; i < len; i++) s += Math.floor(Math.random() * 10);
        digitsInput.value = s;
        handleGenerate();
      });

      downloadBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `color_gradient_${digitsInput.value}.png`;
        link.href = canvas.toDataURL();
        link.click();
      });

      // Initial draw
      handleGenerate();
    })();
  </script>
</body>

</html>