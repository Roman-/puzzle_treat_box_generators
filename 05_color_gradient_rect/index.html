<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Digit Color Encoder</title>
  <style>
    @font-face {
      font-family: 'Novem';
      src: url('../font/Novem-nALvR.ttf');
    }

    @font-face {
      font-family: 'Shrooms';
      src: url('../font/Shrooms-lg65.ttf');
    }

    @font-face {
      font-family: 'Groovy';
      src: url('../font/groovy-zodiac.demo.ttf');
    }

    @font-face {
      font-family: 'Heavytal';
      src: url('../font/heavytal-personal-use.regular.ttf');
    }

    @font-face {
      font-family: 'Metalico';
      src: url('../font/metalico-personal-use.regular.ttf');
    }

    body {
      font-family: sans-serif;
      max-width: 1000px;
      margin: 20px auto;
    }

    label {
      display: inline-block;
      margin: 5px 10px 5px 0;
    }

    hr {
      margin: 20px 0;
      border: none;
      border-top: 1px solid #ccc;
    }

    canvas {
      border: 1px solid #999;
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
      max-width: 100%;
    }

    .controls {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 8px;
    }

    .row {
      margin-bottom: 10px;
    }

    h1 {
      margin-top: 0;
    }

    button {
      cursor: pointer;
    }
  </style>
</head>

<body>
  <h1>Digit Color Encoder</h1>

  <div class="controls">
    <!-- === Dimensions === -->
    <div class="row">
      <label>Width <input id="w" type="number" value="800" min="100" step=10></label>
    </div>

    <!-- === Puzzle Content === -->
    <div class="row">
      <label>Code (digits) <input id="digitsInput" type="text" value="4121" placeholder="e.g. 4121"></label>
      <button id="randomizeBtn" type="button">ðŸŽ²</button>
    </div>

    <hr>

    <!-- === Legend Appearance === -->
    <div class="row">
      <label>Digit Size <input id="digitSize" type="range" min="10" max="100" value="46"
          oninput="this.nextElementSibling.value = this.value"> <output>46</output>px</label>
      <label>Digit Offset <input id="digitOffset" type="range" min="-100" max="100" value="-37"
          oninput="this.nextElementSibling.value = this.value"> <output>-37</output>px</label>
      <label><input id="colorDigit" type="checkbox" checked> Color Digit</label>
    </div>
    <div class="row">
      <label>Digit Font
        <select id="digitFont">
          <option value="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif">System UI</option>
          <option value="Novem">Novem</option>
          <option value="Shrooms">Shrooms</option>
          <option value="Groovy">Groovy</option>
          <option value="Heavytal">Heavytal</option>
          <option value="Metalico">Metalico</option>
        </select>
      </label>
    </div>

    <hr>

    <!-- === Color Properties === -->
    <div class="row">
      <label>Min Saturation <input id="minS" type="range" min="0" max="100" value="80"
          oninput="this.nextElementSibling.value = this.value"> <output>80</output>%</label>
      <label>Max Saturation <input id="maxS" type="range" min="0" max="100" value="100"
          oninput="this.nextElementSibling.value = this.value"> <output>100</output>%</label>
    </div>
    <div class="row">
      <label>Min Value <input id="minV" type="range" min="0" max="100" value="80"
          oninput="this.nextElementSibling.value = this.value"> <output>80</output>%</label>
      <label>Max Value <input id="maxV" type="range" min="0" max="100" value="100"
          oninput="this.nextElementSibling.value = this.value"> <output>100</output>%</label>
    </div>

    <hr>

    <!-- === Question Mark Appearance === -->
    <div class="row">
      <label>Question Mark Size <input id="qmSize" type="range" min="10" max="100" value="32"
          oninput="this.nextElementSibling.value = this.value"> <output>32</output>px</label>
      <label>Question Mark Y-Offset <input id="qmOffset" type="range" min="-50" max="50" value="0"
          oninput="this.nextElementSibling.value = this.value"> <output>0</output>px</label>
    </div>

    <hr>

    <div class="row">
      <button id="downloadBtn" type="button">ðŸ’¾ Download PNG</button>
    </div>

    <div id="error" style="color: red; margin-top: 10px;"></div>
  </div>

  <br>
  <canvas id="canvas"></canvas>

  <script>
// Display current value next to range inputs
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:1px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});
</script>
  <script>
    (function () {
      const digitsInput = document.getElementById('digitsInput');
      const randomizeBtn = document.getElementById('randomizeBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const widthInput = document.getElementById('w');
      const digitSizeInput = document.getElementById('digitSize');
      const digitOffsetInput = document.getElementById('digitOffset');
      const colorDigitInput = document.getElementById('colorDigit');
      const digitFontInput = document.getElementById('digitFont');
      const minSInput = document.getElementById('minS');
      const maxSInput = document.getElementById('maxS');
      const minVInput = document.getElementById('minV');
      const maxVInput = document.getElementById('maxV');
      const qmSizeInput = document.getElementById('qmSize');
      const qmOffsetInput = document.getElementById('qmOffset');
      const errorEl = document.getElementById('error');
      const canvas = document.getElementById('canvas');

      let lastState = null;

      function showError(msg) {
        errorEl.textContent = msg || '';
      }

      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }

      // HSV (0â€“359, 0â€“1, 0â€“1) -> CSS rgb()
      function hsvToCss(h, s, v) {
        const c = v * s;
        const hh = h / 60;
        const x = c * (1 - Math.abs(hh % 2 - 1));
        let r1 = 0, g1 = 0, b1 = 0;

        if (hh >= 0 && hh < 1) {
          r1 = c; g1 = x; b1 = 0;
        } else if (hh >= 1 && hh < 2) {
          r1 = x; g1 = c; b1 = 0;
        } else if (hh >= 2 && hh < 3) {
          r1 = 0; g1 = c; b1 = x;
        } else if (hh >= 3 && hh < 4) {
          r1 = 0; g1 = x; b1 = c;
        } else if (hh >= 4 && hh < 5) {
          r1 = x; g1 = 0; b1 = c;
        } else {
          r1 = c; g1 = 0; b1 = x;
        }

        const m = v - c;
        const r = Math.round((r1 + m) * 255);
        const g = Math.round((g1 + m) * 255);
        const b = Math.round((b1 + m) * 255);
        return 'rgb(' + r + ',' + g + ',' + b + ')';
      }

      // Step 2: build sorted array of EXACTLY 6 digits containing all input digits
      function buildDigitSet(input) {
        const digits = input.split('').map(ch => parseInt(ch, 10));
        const unique = Array.from(new Set(digits)).sort((a, b) => a - b);
        const allDigits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        const remaining = allDigits.filter(d => !unique.includes(d));

        // We want exactly 6 items in the legend
        const targetK = 6;

        shuffle(remaining);
        const extraNeeded = targetK - unique.length;
        // extraNeeded should be >= 0 because we validate unique.length <= 6 before calling this
        const extra = remaining.slice(0, Math.max(0, extraNeeded));

        const result = unique.concat(extra).sort((a, b) => a - b);
        return result;
      }

      // Step 3: assign HSV colors to each digit in digitSet
      function buildColorMap(digitSet) {
        const map = new Map();

        // Get ranges
        const minS = parseInt(minSInput.value, 10) / 100;
        const maxS = parseInt(maxSInput.value, 10) / 100;
        const minV = parseInt(minVInput.value, 10) / 100;
        const maxV = parseInt(maxVInput.value, 10) / 100;

        // Guaranteed distinct hues: 60 degrees apart
        const startHue = Math.floor(Math.random() * 360);
        const hues = [];
        for (let i = 0; i < 6; i++) {
          hues.push((startHue + i * 60) % 360);
        }
        shuffle(hues); // Randomize assignment to digits

        digitSet.forEach((d, i) => {
          const hue = hues[i];
          // Random S and V within range for each color
          const s = minS + Math.random() * (maxS - minS);
          const v = minV + Math.random() * (maxV - minV);

          map.set(d, {
            css: hsvToCss(hue, s, v),
            h: hue,
            s: s,
            v: v
          });
        });

        // Return a representative S/V for the gradient boundaries (using average or just mid-range)
        // Actually, we'll generate boundary colors separately using the same ranges
        return { map, minS, maxS, minV, maxV };
      }

      function clearCanvas() {
        const ctx = canvas.getContext('2d');
        const width = parseInt(widthInput.value, 10) || 800;
        canvas.width = width;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      // Step 4 & 5: draw legend and encoding stripe
      function drawCanvas(state) {
        const { input, digitSet, colors, minS, maxS, minV, maxV } = state;
        const ctx = canvas.getContext('2d');

        const width = parseInt(widthInput.value, 10) || 800;
        const digitSize = parseInt(digitSizeInput.value, 10) || 46;
        const digitOffset = parseInt(digitOffsetInput.value, 10) || -37;
        const colorDigit = colorDigitInput.checked;
        const digitFont = digitFontInput.value;
        const qmSize = parseInt(qmSizeInput.value, 10) || 32;
        const qmOffset = parseInt(qmOffsetInput.value, 10) || 0;

        canvas.width = width;

        const margin = 32;
        const legendCellHeight = 70;
        const legendTitleHeight = 24;

        // Fixed 3 columns for 6 items -> 2 rows
        const columns = 3;
        const rows = Math.ceil(digitSet.length / columns);
        const legendHeight = rows * legendCellHeight;

        const strapHeight = 90;
        const strapTopMargin = 40;
        const strapBottomMargin = 20;
        const questionBlockHeight = 70;

        const totalHeight =
          margin +
          legendHeight +
          strapTopMargin +
          strapHeight +
          strapBottomMargin +
          questionBlockHeight;

        canvas.height = totalHeight;

        const ctx2 = canvas.getContext('2d');

        // Background
        ctx2.clearRect(0, 0, canvas.width, canvas.height);
        ctx2.fillStyle = '#ffffff';
        ctx2.fillRect(0, 0, canvas.width, canvas.height);

        // Legend grid: digit + colored circle
        const gridWidth = width - margin * 2;
        const cellWidth = gridWidth / columns;
        const circleRadius = 16;
        let y = margin;

        digitSet.forEach((digit, index) => {
          const row = Math.floor(index / columns);
          const col = index % columns;
          const cellX = margin + col * cellWidth;
          const cellY = y + row * legendCellHeight;

          const cx = cellX + cellWidth / 2;
          const cy = cellY + legendCellHeight / 2;

          const colorObj = colors.get(digit);

          // Draw Circle
          ctx2.beginPath();
          ctx2.arc(cx, cy, circleRadius, 0, Math.PI * 2);
          ctx2.fillStyle = colorObj.css;
          ctx2.fill();
          ctx2.lineWidth = 1;
          ctx2.strokeStyle = 'rgba(17, 24, 39, 0.2)';
          ctx2.stroke();

          // Draw Digit
          ctx2.font = `${digitSize}px ${digitFont}`;
          ctx2.fillStyle = colorDigit ? colorObj.css : '#111827';
          ctx2.textAlign = 'center';
          ctx2.textBaseline = 'middle';

          ctx2.fillText(String(digit), cx + digitOffset, cy);
        });

        const legendBottomY = y + rows * legendCellHeight;

        // Encoding stripe (wide rectangle)
        const strapX = margin;
        const strapY = legendBottomY + strapTopMargin;
        const strapWidth = width - margin * 2;

        // Left/right random boundary colors
        // We want them to be distinct from the first/last digit colors if possible, 
        // but for now just random hues with random S/V in range is fine.
        const leftHue = Math.floor(Math.random() * 360);
        const leftS = minS + Math.random() * (maxS - minS);
        const leftV = minV + Math.random() * (maxV - minV);

        const rightHue = Math.floor(Math.random() * 360);
        const rightS = minS + Math.random() * (maxS - minS);
        const rightV = minV + Math.random() * (maxV - minV);

        const leftColor = hsvToCss(leftHue, leftS, leftV);
        const rightColor = hsvToCss(rightHue, rightS, rightV);

        const gradient = ctx2.createLinearGradient(strapX, 0, strapX + strapWidth, 0);
        gradient.addColorStop(0, leftColor);

        // N points along the stripe, one per digit in input, in order
        const N = input.length;
        if (N > 0) {
          const step = 1 / (N + 1);

          for (let i = 0; i < N; i++) {
            const pos = (i + 1) * step; // in (0,1)
            const d = parseInt(input[i], 10);
            const colorObj = colors.get(d);
            gradient.addColorStop(pos, colorObj.css);
          }

          gradient.addColorStop(1, rightColor);

          // Fill stripe
          ctx2.fillStyle = gradient;
          ctx2.fillRect(strapX, strapY, strapWidth, strapHeight);

          // Border
          ctx2.lineWidth = 2;
          ctx2.strokeStyle = 'rgba(17, 24, 39, 0.2)';
          ctx2.strokeRect(strapX, strapY, strapWidth, strapHeight);

          // Markers and Question Marks
          const markerY = strapY + strapHeight / 2;
          const qY = strapY + strapHeight + strapBottomMargin + qmOffset;

          ctx2.textAlign = 'center';
          ctx2.textBaseline = 'top';
          ctx2.font = `${qmSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

          for (let i = 0; i < N; i++) {
            const pos = (i + 1) * step;
            const x = strapX + strapWidth * pos;
            const d = parseInt(input[i], 10);
            const colorObj = colors.get(d);

            // Marker on stripe
            ctx2.beginPath();
            ctx2.arc(x, markerY, 4.5, 0, Math.PI * 2);
            ctx2.fillStyle = colorObj.css;
            ctx2.fill();
            ctx2.lineWidth = 1;
            ctx2.strokeStyle = 'rgba(255, 255, 255, 0.75)';
            ctx2.stroke();

            // Question mark below
            ctx2.fillStyle = '#111827';
            ctx2.fillText('?', x, qY);
          }

        } else {
          // Just a simple left-right gradient if somehow N == 0
          gradient.addColorStop(1, rightColor);
          ctx2.fillStyle = gradient;
          ctx2.fillRect(strapX, strapY, strapWidth, strapHeight);
          ctx2.lineWidth = 2;
          ctx2.strokeStyle = 'rgba(17, 24, 39, 0.2)';
          ctx2.strokeRect(strapX, strapY, strapWidth, strapHeight);
        }
      }

      function handleGenerate() {
        const raw = digitsInput.value.trim();

        if (!raw) {
          showError('Please enter at least one digit.');
          clearCanvas();
          return;
        }
        if (!/^\d+$/.test(raw)) {
          showError('Use digits 0â€“9 only (no spaces or other characters).');
          clearCanvas();
          return;
        }

        // Validate unique digits count <= 6
        const uniqueCount = new Set(raw.split('')).size;
        if (uniqueCount > 6) {
          showError('Please enter at most 6 unique digits (you entered ' + uniqueCount + ').');
          clearCanvas();
          return;
        }

        if (raw.length > 20) { // Increased limit slightly, main constraint is unique digits
          showError('Please enter at most 20 digits.');
          clearCanvas();
          return;
        }

        showError('');

        const digitSet = buildDigitSet(raw);
        const { map, minS, maxS, minV, maxV } = buildColorMap(digitSet);

        const state = {
          input: raw,
          digitSet,
          colors: map,
          minS, maxS, minV, maxV
        };

        lastState = state;
        drawCanvas(state);
      }

      // Event Listeners
      const inputs = [
        widthInput, digitSizeInput, digitOffsetInput, colorDigitInput, digitFontInput,
        minSInput, maxSInput, minVInput, maxVInput,
        qmSizeInput, qmOffsetInput
      ];
      inputs.forEach(el => el.addEventListener('input', () => {
        if (lastState) {
          // Re-generate colors if S/V changed, or just redraw?
          // If we just redraw, we need to update the colors in the state.
          // Since colors are random within range, dragging the slider would cause disco effect if we re-gen every frame.
          // Ideally we should only re-gen colors if we explicitly want to.
          // But here, let's just re-call handleGenerate which rebuilds everything.
          handleGenerate();
        }
      }));

      // Ensure fonts are loaded before drawing (simple delay or just rely on redraw)
      document.fonts.ready.then(() => {
        if (lastState) drawCanvas(lastState);
      });

      digitsInput.addEventListener('input', handleGenerate);

      randomizeBtn.addEventListener('click', () => {
        const len = Math.random() > 0.5 ? 4 : 5;
        let s = '';
        for (let i = 0; i < len; i++) s += Math.floor(Math.random() * 10);
        digitsInput.value = s;
        handleGenerate();
      });

      downloadBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `color_gradient_${digitsInput.value}.png`;
        link.href = canvas.toDataURL();
        link.click();
      });

      // Initial draw
      handleGenerate();
    })();
  </script>
</body>

</html>