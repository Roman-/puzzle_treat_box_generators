<!doctype html>
<meta charset="utf-8">
<title>Domino Chain Decoder â€“ generator</title>

<!-- === size first === -->
<label>W <input id=w type=number value=1200 min=50></label>
<label>H <input id=h type=number value=400 min=50></label>

<!-- === code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{3,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === creativity === -->
<label>Domino size
  <input id=dominoSize type=range min=0.4 max=0.95 step=0.05 value=0.8>
</label><br>

<label>Pip size
  <input id=pipSize type=range min=0.06 max=0.18 step=0.01 value=0.11>
</label><br>

<label>Corner radius
  <input id=cornerRadius type=range min=0 max=0.15 step=0.01 value=0.08>
</label><br>

<label>Domino gap
  <input id=dominoGap type=range min=0 max=0.3 step=0.02 value=0.1>
</label><br>

<label><input id=showDivider type=checkbox checked> Show center divider</label><br>

<label><input id=show3D type=checkbox checked> 3D shadow effect</label><br>

<label>Pip color
  <input id=pipColor type=color value="#1a1a1a">
</label><br>

<label>Domino color
  <input id=dominoColor type=color value="#f5f5dc">
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>

<hr>

<canvas id=can title="Click to download"
        style="border:1px solid grey;cursor:pointer"></canvas>

<script>
// Display current value next to range inputs
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:4px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});
</script>
<script>
const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'domino_chain';
const DEF = {
  w: 1200, h: 400, code: '1234',
  dominoSize: 0.8, pipSize: 0.11, cornerRadius: 0.08, dominoGap: 0.1,
  showDivider: true, show3D: true,
  pipColor: '#1a1a1a', dominoColor: '#f5f5dc'
};

// Pip positions for 0-9 in a 3x3 grid (positions 0-8)
// Grid:  0 1 2
//        3 4 5
//        6 7 8
const pipPatterns = {
  0: [],
  1: [4],
  2: [0, 8],
  3: [0, 4, 8],
  4: [0, 2, 6, 8],
  5: [0, 2, 4, 6, 8],
  6: [0, 2, 3, 5, 6, 8],
  7: [0, 2, 3, 4, 5, 6, 8],
  8: [0, 1, 2, 3, 5, 6, 7, 8],
  9: [0, 1, 2, 3, 4, 5, 6, 7, 8]
};

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  const codeStr = $('code').value || '1234';
  const digits = codeStr.split('').map(Number).filter(d => !isNaN(d));
  const N = digits.length || 4;

  // Each domino holds 2 digits, so we need ceil(N/2) dominoes
  const numDominoes = Math.ceil(N / 2);

  const dominoSizeFrac = +$('dominoSize').value;
  const pipSizeFrac = +$('pipSize').value;
  const cornerRadiusFrac = +$('cornerRadius').value;
  const dominoGapFrac = +$('dominoGap').value;
  const showDivider = $('showDivider').checked;
  const show3D = $('show3D').checked;
  const pipColor = $('pipColor').value;
  const dominoColor = $('dominoColor').value;

  // Calculate domino dimensions
  // Domino aspect ratio is 2:1 (width:height per half, so full domino is 2:1)
  const maxDominoH = H * dominoSizeFrac;
  const dominoH = maxDominoH;
  const halfW = dominoH; // Each half is square
  const dominoW = halfW * 2;

  const totalDominoWidth = numDominoes * dominoW;
  const totalGapWidth = (numDominoes - 1) * dominoW * dominoGapFrac;
  const totalWidth = totalDominoWidth + totalGapWidth;

  const scale = Math.min(1, (W * 0.9) / totalWidth);
  const actualDominoW = dominoW * scale;
  const actualDominoH = dominoH * scale;
  const actualHalfW = halfW * scale;
  const actualGap = actualDominoW * dominoGapFrac;

  const startX = (W - (numDominoes * actualDominoW + (numDominoes - 1) * actualGap)) / 2;
  const startY = (H - actualDominoH) / 2;

  // Draw each domino
  for (let d = 0; d < numDominoes; d++) {
    const x = startX + d * (actualDominoW + actualGap);
    const y = startY;

    const leftDigit = digits[d * 2] !== undefined ? digits[d * 2] : 0;
    const rightDigit = digits[d * 2 + 1] !== undefined ? digits[d * 2 + 1] : null;

    drawDomino(x, y, actualDominoW, actualDominoH, leftDigit, rightDigit, {
      cornerRadiusFrac, pipSizeFrac, showDivider, show3D, pipColor, dominoColor
    });
  }
}

function drawDomino(x, y, w, h, leftDigit, rightDigit, opts) {
  const radius = h * opts.cornerRadiusFrac;
  const halfW = w / 2;

  // 3D shadow
  if (opts.show3D) {
    const shadowOffset = h * 0.04;
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    roundRect(x + shadowOffset, y + shadowOffset, w, h, radius, true, false);
  }

  // Domino body
  ctx.fillStyle = opts.dominoColor;
  ctx.strokeStyle = '#333';
  ctx.lineWidth = Math.max(1, h * 0.02);
  roundRect(x, y, w, h, radius, true, true);

  // Center divider
  if (opts.showDivider) {
    ctx.strokeStyle = '#666';
    ctx.lineWidth = Math.max(1, h * 0.015);
    ctx.beginPath();
    ctx.moveTo(x + halfW, y + h * 0.1);
    ctx.lineTo(x + halfW, y + h * 0.9);
    ctx.stroke();
  }

  // Draw pips on left half
  drawPips(x, y, halfW, h, leftDigit, opts.pipSizeFrac, opts.pipColor);

  // Draw pips on right half (if exists)
  if (rightDigit !== null) {
    drawPips(x + halfW, y, halfW, h, rightDigit, opts.pipSizeFrac, opts.pipColor);
  } else {
    // Mark unused half with X
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = Math.max(1, h * 0.02);
    const margin = halfW * 0.2;
    ctx.beginPath();
    ctx.moveTo(x + halfW + margin, y + margin);
    ctx.lineTo(x + w - margin, y + h - margin);
    ctx.moveTo(x + w - margin, y + margin);
    ctx.lineTo(x + halfW + margin, y + h - margin);
    ctx.stroke();
  }
}

function drawPips(x, y, w, h, digit, pipSizeFrac, pipColor) {
  const pattern = pipPatterns[digit] || [];
  const pipR = h * pipSizeFrac;
  const padding = w * 0.2;
  const innerW = w - 2 * padding;
  const innerH = h - 2 * padding;

  ctx.fillStyle = pipColor;

  pattern.forEach(pos => {
    const col = pos % 3;
    const row = Math.floor(pos / 3);
    const px = x + padding + (col / 2) * innerW;
    const py = y + padding + (row / 2) * innerH;

    ctx.beginPath();
    ctx.arc(px, py, pipR, 0, Math.PI * 2);
    ctx.fill();
  });
}

function roundRect(x, y, w, h, r, fill, stroke) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

// Live preview
oninput = draw;
draw();

// Random code
function randCode() {
  const len = $('code').value.length || 4;
  $('code').value = Array.from({length: len}, () => Math.floor(Math.random() * 10)).join('');
}

document.querySelectorAll('[data-t]').forEach(b => b.onclick = () => {
  if (b.dataset.t === 'code') { randCode(); draw(); }
});

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    if (el.type === 'checkbox') el.checked = DEF[k];
    else el.value = DEF[k];
  }
  document.querySelectorAll('input[type=range]').forEach(r => {
    const span = r.nextElementSibling;
    if (span && span.tagName === 'SPAN') span.textContent = r.value;
  });
  draw();
};

// Click to download
$('can').onclick = () => {
  const c = $('code').value || '1234';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};
</script>
