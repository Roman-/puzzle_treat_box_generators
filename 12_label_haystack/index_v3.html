<!doctype html>
<meta charset="utf-8">
<title>Label Haystack (Shapes) â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=600 min=100></label>

<!-- === code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === rule settings === -->
<label>Target Shape
  <select id=targetShape>
    <option value="random" selected>Random</option>
    <option value="circle">Circle</option>
    <option value="square">Square</option>
    <option value="triangle">Triangle</option>
    <option value="star">Star</option>
  </select>
</label>

<button id=newRule type=button>ðŸ”€ New Shape</button><br>

<label>Current Rule: <strong id=currentRuleDisplay>â€”</strong></label><br>

<hr>

<!-- === visual settings === -->
<label>Total labels
  <input id=labelCount type=range min=10 max=40 step=1 value=18>
  <span id=labelCountVal>18</span>
</label><br>

<label>Labels with shapes (%)
  <input id=shapedPct type=range min=30 max=80 step=5 value=50>
</label><br>

<label>Label size (% of height)
  <input id=labelSize type=range min=6 max=15 step=1 value=9>
</label><br>

<label>Shape padding (% of label)
  <input id=shapePadding type=range min=20 max=60 step=5 value=35>
</label><br>

<label>Shape line thickness
  <input id=shapeThickness type=range min=2 max=8 step=1 value=3>
</label><br>

<label>Rotation variance (degrees)
  <input id=rotation type=range min=0 max=25 step=1 value=10>
</label><br>

<label>Grid jitter (% of cell)
  <input id=jitter type=range min=0 max=35 step=1 value=15>
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>

const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'label_haystack_shapes';

const SHAPES = ['circle', 'square', 'triangle', 'star'];
const SHAPE_NAMES = {
  circle: 'CIRCLE',
  square: 'SQUARE',
  triangle: 'TRIANGLE',
  star: 'STAR'
};

const DEF = {
  w: 800, h: 600, code: '1234',
  targetShape: 'random', labelCount: 18,
  shapedPct: 50, labelSize: 9,
  shapePadding: 35, shapeThickness: 3,
  rotation: 10, jitter: 15
};

// State
let currentShape = 'circle';
let labels = []; // { value, x, y, rotation, shape (null or string), isAnswer }

const randomElement = arr => arr[Math.floor(Math.random() * arr.length)];
const shuffle = arr => {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};

function selectShape() {
  const sel = $('targetShape').value;
  if (sel === 'random') {
    currentShape = randomElement(SHAPES);
  } else {
    currentShape = sel;
  }
  $('currentRuleDisplay').textContent = `Find the number in the ${SHAPE_NAMES[currentShape]}`;
}

function generateRandomCode(length) {
  let code = '';
  for (let i = 0; i < length; i++) {
    code += Math.floor(Math.random() * 10);
  }
  return code;
}

function generateLabels() {
  const codeStr = $('code').value || '1234';
  const numLabels = +$('labelCount').value;
  const shapedPct = +$('shapedPct').value / 100;
  const jitterPct = +$('jitter').value / 100;
  const rotationVar = +$('rotation').value;
  const W = +$('w').value;
  const H = +$('h').value;

  const ruleAreaHeight = H * 0.12;
  const areaTop = ruleAreaHeight + 15;
  const areaHeight = H - areaTop - 15;
  const areaWidth = W - 30;

  // Calculate grid
  const cols = Math.ceil(Math.sqrt(numLabels * (areaWidth / areaHeight)));
  const rows = Math.ceil(numLabels / cols);
  const cellW = areaWidth / cols;
  const cellH = areaHeight / rows;

  // Generate grid positions
  const positions = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const baseX = 15 + c * cellW + cellW / 2;
      const baseY = areaTop + r * cellH + cellH / 2;
      const jitterX = (Math.random() - 0.5) * cellW * jitterPct;
      const jitterY = (Math.random() - 0.5) * cellH * jitterPct;
      positions.push({ x: baseX + jitterX, y: baseY + jitterY });
    }
  }
  shuffle(positions);

  // Generate unique values
  const allValues = new Set([codeStr]);
  while (allValues.size < numLabels) {
    allValues.add(generateRandomCode(codeStr.length));
  }
  const valuesArray = Array.from(allValues);
  shuffle(valuesArray);

  // Determine how many labels get shapes
  const numShaped = Math.floor(numLabels * shapedPct);
  const numPlain = numLabels - numShaped;

  // Other shapes for decoys
  const otherShapes = SHAPES.filter(s => s !== currentShape);

  labels = [];
  let posIdx = 0;

  // Answer label (with target shape)
  labels.push({
    value: codeStr,
    x: positions[posIdx].x,
    y: positions[posIdx].y,
    rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
    shape: currentShape,
    isAnswer: true
  });
  posIdx++;

  // Other shaped labels (decoys with different shapes)
  for (let i = 1; i < numShaped && posIdx < numLabels; i++) {
    labels.push({
      value: valuesArray[posIdx],
      x: positions[posIdx].x,
      y: positions[posIdx].y,
      rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
      shape: randomElement(otherShapes),
      isAnswer: false
    });
    posIdx++;
  }

  // Plain labels (no shape)
  while (posIdx < numLabels) {
    labels.push({
      value: valuesArray[posIdx],
      x: positions[posIdx].x,
      y: positions[posIdx].y,
      rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
      shape: null,
      isAnswer: false
    });
    posIdx++;
  }

  shuffle(labels);
}

function drawShape(x, y, width, height, shape, thickness) {
  ctx.strokeStyle = '#333';
  ctx.lineWidth = thickness;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  const hw = width / 2;
  const hh = height / 2;

  ctx.beginPath();

  switch (shape) {
    case 'circle':
      ctx.ellipse(x, y, hw, hh, 0, 0, Math.PI * 2);
      break;

    case 'square':
      ctx.rect(x - hw, y - hh, width, height);
      break;

    case 'triangle':
      ctx.moveTo(x, y - hh);
      ctx.lineTo(x + hw, y + hh);
      ctx.lineTo(x - hw, y + hh);
      ctx.closePath();
      break;

    case 'star':
      const outerR = Math.max(hw, hh);
      const innerR = outerR * 0.4;
      const points = 5;
      for (let i = 0; i < points * 2; i++) {
        const r = i % 2 === 0 ? outerR : innerR;
        const angle = (i * Math.PI / points) - Math.PI / 2;
        const px = x + r * Math.cos(angle);
        const py = y + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      break;
  }

  ctx.stroke();
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;

  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  if (labels.length === 0) {
    generateLabels();
  }

  const fontSize = H * (+$('labelSize').value / 100);
  const shapePadding = +$('shapePadding').value / 100;
  const shapeThickness = +$('shapeThickness').value;
  const ruleAreaHeight = H * 0.12;

  // Draw rule text
  ctx.fillStyle = '#333';
  ctx.font = `bold ${ruleAreaHeight * 0.55}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(
    `Find the number in the ${SHAPE_NAMES[currentShape]}`,
    W / 2, ruleAreaHeight / 2
  );

  // Draw separator
  ctx.beginPath();
  ctx.moveTo(W * 0.05, ruleAreaHeight);
  ctx.lineTo(W * 0.95, ruleAreaHeight);
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Draw labels
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;

  for (const label of labels) {
    ctx.save();
    ctx.translate(label.x, label.y);
    ctx.rotate(label.rotation);

    // Measure text for shape sizing
    const metrics = ctx.measureText(label.value);
    const textWidth = metrics.width;
    const textHeight = fontSize;

    // Draw shape if present
    if (label.shape) {
      const shapeW = textWidth * (1 + shapePadding);
      const shapeH = textHeight * (1 + shapePadding);
      drawShape(0, 0, shapeW, shapeH, label.shape, shapeThickness);
    }

    // Draw text
    ctx.fillStyle = '#333';
    ctx.fillText(label.value, 0, 0);

    ctx.restore();
  }

  $('labelCountVal').textContent = $('labelCount').value;
}

// Event handlers
function randCode() {
  const numDigits = ($('code').value || '').length || 4;
  $('code').value = generateRandomCode(numDigits);
  generateLabels();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => {
    if (b.dataset.t === 'code') { randCode(); draw(); }
  };
});

$('newRule').onclick = () => {
  selectShape();
  generateLabels();
  draw();
};

$('targetShape').onchange = () => {
  selectShape();
  generateLabels();
  draw();
};

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    el.value = DEF[k];
  }
  selectShape();
  generateLabels();
  draw();
};

$('code').oninput = () => { generateLabels(); draw(); };
$('labelCount').oninput = () => { generateLabels(); draw(); };
$('shapedPct').oninput = () => { generateLabels(); draw(); };
$('jitter').oninput = () => { generateLabels(); draw(); };
$('rotation').oninput = () => { generateLabels(); draw(); };

document.querySelectorAll('input[type=range]').forEach(el => {
  if (!['labelCount', 'shapedPct', 'jitter', 'rotation'].includes(el.id)) {
    el.oninput = draw;
  }
});

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};

// Initial setup
selectShape();
generateLabels();
draw();

</script>
