<!doctype html>
<meta charset="utf-8">
<title>Label Haystack (Color + Size) â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=600 min=100></label>

<!-- === code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === rule settings === -->
<label>Target Color
  <select id=targetColor>
    <option value="random" selected>Random</option>
  </select>
</label>

<label>Size Rule
  <select id=sizeRule>
    <option value="smallest" selected>Smallest</option>
    <option value="biggest">Biggest</option>
  </select>
</label>

<button id=newRule type=button>ðŸ”€ New Rule</button><br>

<label>Current Rule: <strong id=currentRuleDisplay>â€”</strong></label><br>

<hr>

<!-- === visual settings === -->
<label>Total labels
  <input id=labelCount type=range min=12 max=40 step=1 value=20>
  <span id=labelCountVal>20</span>
</label><br>

<label>Same-color labels (including answer)
  <input id=sameColorCount type=range min=3 max=8 step=1 value=4>
  <span id=sameColorCountVal>4</span>
</label><br>

<label>Base label size (% of height)
  <input id=labelSize type=range min=6 max=15 step=1 value=9>
</label><br>

<label>Size variation (multiplier range)
  <input id=sizeVariation type=range min=1.5 max=3.0 step=0.1 value=2.0>
</label><br>

<label>Rotation variance (degrees)
  <input id=rotation type=range min=0 max=30 step=1 value=15>
</label><br>

<label>Grid jitter (% of cell)
  <input id=jitter type=range min=0 max=40 step=1 value=20>
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script src="../shared/colors.js"></script>
<script>

const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'label_haystack_color_size';

// Populate color dropdown using BASIC_COLORS (pure, recognizable colors)
BASIC_COLORS.forEach((c, i) => {
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = c.name;
  $('targetColor').appendChild(opt);
});

const DEF = {
  w: 800, h: 600, code: '1234',
  targetColor: 'random', sizeRule: 'smallest',
  labelCount: 20, sameColorCount: 4,
  labelSize: 9, sizeVariation: 2.0,
  rotation: 15, jitter: 20
};

// State
let currentColorIndex = 0;
let currentSizeRule = 'smallest';
let labels = []; // { value, x, y, rotation, colorIndex, sizeMult, isAnswer }

const randomElement = arr => arr[Math.floor(Math.random() * arr.length)];
const shuffle = arr => {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};

function selectRule() {
  const colorSel = $('targetColor').value;
  if (colorSel === 'random') {
    currentColorIndex = Math.floor(Math.random() * BASIC_COLORS.length);
  } else {
    currentColorIndex = parseInt(colorSel);
  }
  currentSizeRule = $('sizeRule').value;
  $('currentRuleDisplay').textContent =
    `Find the ${currentSizeRule} ${BASIC_COLORS[currentColorIndex].name.toUpperCase()} label`;
}

function generateRandomCode(length) {
  let code = '';
  for (let i = 0; i < length; i++) {
    code += Math.floor(Math.random() * 10);
  }
  return code;
}

function generateLabels() {
  const codeStr = $('code').value || '1234';
  const numLabels = +$('labelCount').value;
  const sameColorCount = Math.min(+$('sameColorCount').value, numLabels - 2);
  const jitterPct = +$('jitter').value / 100;
  const rotationVar = +$('rotation').value;
  const sizeVar = +$('sizeVariation').value;
  const W = +$('w').value;
  const H = +$('h').value;

  const ruleAreaHeight = H * 0.12;
  const areaTop = ruleAreaHeight + 10;
  const areaHeight = H - areaTop - 10;
  const areaWidth = W - 20;

  // Calculate grid
  const cols = Math.ceil(Math.sqrt(numLabels * (areaWidth / areaHeight)));
  const rows = Math.ceil(numLabels / cols);
  const cellW = areaWidth / cols;
  const cellH = areaHeight / rows;

  // Generate grid positions
  const positions = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const baseX = 10 + c * cellW + cellW / 2;
      const baseY = areaTop + r * cellH + cellH / 2;
      const jitterX = (Math.random() - 0.5) * cellW * jitterPct;
      const jitterY = (Math.random() - 0.5) * cellH * jitterPct;
      positions.push({ x: baseX + jitterX, y: baseY + jitterY });
    }
  }
  shuffle(positions);

  // Generate unique values
  const allValues = new Set([codeStr]);
  while (allValues.size < numLabels) {
    allValues.add(generateRandomCode(codeStr.length));
  }
  const valuesArray = Array.from(allValues);
  shuffle(valuesArray);

  // Get non-target colors
  const otherColors = BASIC_COLORS.map((_, i) => i).filter(i => i !== currentColorIndex);

  // Generate size multipliers for same-color labels
  // Answer gets extreme size, others get middle values
  const sizeMultipliers = [];
  const minMult = 1 / sizeVar;
  const maxMult = sizeVar;

  if (currentSizeRule === 'smallest') {
    sizeMultipliers.push(minMult); // Answer
    for (let i = 1; i < sameColorCount; i++) {
      // Middle to large sizes (never as small as answer)
      sizeMultipliers.push(minMult * 1.5 + Math.random() * (maxMult - minMult * 1.5));
    }
  } else {
    sizeMultipliers.push(maxMult); // Answer
    for (let i = 1; i < sameColorCount; i++) {
      // Small to middle sizes (never as large as answer)
      sizeMultipliers.push(minMult + Math.random() * (maxMult * 0.7 - minMult));
    }
  }

  labels = [];
  let posIdx = 0;
  let valIdx = 0;

  // Answer label (first same-color label)
  labels.push({
    value: codeStr,
    x: positions[posIdx].x,
    y: positions[posIdx].y,
    rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
    colorIndex: currentColorIndex,
    sizeMult: sizeMultipliers[0],
    isAnswer: true
  });
  posIdx++;
  valIdx++; // Skip codeStr in valuesArray

  // Other same-color labels (decoys)
  for (let i = 1; i < sameColorCount; i++) {
    labels.push({
      value: valuesArray[valIdx],
      x: positions[posIdx].x,
      y: positions[posIdx].y,
      rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
      colorIndex: currentColorIndex,
      sizeMult: sizeMultipliers[i],
      isAnswer: false
    });
    posIdx++;
    valIdx++;
  }

  // Other-color labels (full distractors)
  while (posIdx < numLabels && valIdx < valuesArray.length) {
    labels.push({
      value: valuesArray[valIdx],
      x: positions[posIdx].x,
      y: positions[posIdx].y,
      rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
      colorIndex: randomElement(otherColors),
      sizeMult: minMult + Math.random() * (maxMult - minMult), // Random size
      isAnswer: false
    });
    posIdx++;
    valIdx++;
  }

  shuffle(labels);
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;

  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  if (labels.length === 0) {
    generateLabels();
  }

  const baseFontSize = H * (+$('labelSize').value / 100);
  const ruleAreaHeight = H * 0.12;

  // Draw rule text
  ctx.fillStyle = '#333';
  ctx.font = `bold ${ruleAreaHeight * 0.55}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(
    `Find the ${currentSizeRule} ${BASIC_COLORS[currentColorIndex].name.toUpperCase()} label`,
    W / 2, ruleAreaHeight / 2
  );

  // Draw separator
  ctx.beginPath();
  ctx.moveTo(W * 0.05, ruleAreaHeight);
  ctx.lineTo(W * 0.95, ruleAreaHeight);
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Draw labels
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (const label of labels) {
    const fontSize = baseFontSize * label.sizeMult;
    ctx.save();
    ctx.translate(label.x, label.y);
    ctx.rotate(label.rotation);
    ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
    ctx.fillStyle = BASIC_COLOR_HEX[label.colorIndex];
    ctx.fillText(label.value, 0, 0);
    ctx.restore();
  }

  $('labelCountVal').textContent = $('labelCount').value;
  $('sameColorCountVal').textContent = $('sameColorCount').value;
}

// Event handlers
function randCode() {
  const numDigits = ($('code').value || '').length || 4;
  $('code').value = generateRandomCode(numDigits);
  generateLabels();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => {
    if (b.dataset.t === 'code') { randCode(); draw(); }
  };
});

$('newRule').onclick = () => {
  selectRule();
  generateLabels();
  draw();
};

$('targetColor').onchange = () => {
  selectRule();
  generateLabels();
  draw();
};

$('sizeRule').onchange = () => {
  selectRule();
  generateLabels();
  draw();
};

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    el.value = DEF[k];
  }
  selectRule();
  generateLabels();
  draw();
};

$('code').oninput = () => { generateLabels(); draw(); };
$('labelCount').oninput = () => { generateLabels(); draw(); };
$('sameColorCount').oninput = () => { generateLabels(); draw(); };
$('jitter').oninput = () => { generateLabels(); draw(); };
$('rotation').oninput = () => { generateLabels(); draw(); };
$('sizeVariation').oninput = () => { generateLabels(); draw(); };
$('labelSize').oninput = draw;

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};

// Initial setup
selectRule();
generateLabels();
draw();

</script>
