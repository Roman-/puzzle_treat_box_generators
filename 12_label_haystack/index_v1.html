<!doctype html>
<meta charset="utf-8">
<title>Label Haystack (Color) ‚Äì generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=600 min=100></label>

<!-- === code + üé≤ === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">üé≤</button>

<hr>

<!-- === rule settings === -->
<label>Target Color
  <select id=targetColor>
    <option value="random" selected>Random</option>
  </select>
</label>
<button id=newRule type=button>üîÄ New Color</button><br>

<label>Current Rule: <strong id=currentRuleDisplay>‚Äî</strong></label><br>

<hr>

<!-- === visual settings === -->
<label>Question style
  <select id=questionStyle>
    <option value="visual" selected>Visual (‚óè ‚Äì ?)</option>
    <option value="text">Text</option>
  </select>
</label><br>

<label>Number of labels
  <input id=labelCount type=range min=10 max=50 step=1 value=20>
</label><br>

<label>Target color count
  <input id=targetColorCount type=range min=2 max=10 step=1 value=5>
</label><br>

<label>Label size (% of height)
  <input id=labelSize type=range min=3 max=15 step=1 value=8>
</label><br>

<label>Rotation variance (degrees)
  <input id=rotation type=range min=0 max=30 step=1 value=15>
</label><br>

<label>Grid jitter (% of cell)
  <input id=jitter type=range min=0 max=40 step=1 value=20>
</label><br>

<button id=reset type=button>üîÑ Restore defaults</button>
<button id=rerender type=button>üîÅ Re-render</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
// Display current value next to range inputs
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:4px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});
</script>
<script>

const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'label_haystack_color';

const BASIC_COLORS = [
  { hex: '#E00000', name: 'Red' },
  { hex: '#0000DD', name: 'Blue' },
  { hex: '#008800', name: 'Green' },
  { hex: '#CC9900', name: 'Yellow' },
  { hex: '#CC00CC', name: 'Purple' },
];
const BASIC_COLOR_HEX = BASIC_COLORS.map(c => c.hex);

// Populate color dropdown
BASIC_COLORS.forEach((c, i) => {
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = c.name;
  $('targetColor').appendChild(opt);
});

const DEF = {
  w: 800, h: 600, code: '1234',
  targetColor: 'random', labelCount: 20, targetColorCount: 5,
  labelSize: 8, rotation: 15, jitter: 20, questionStyle: 'visual'
};

// State
let currentColorIndex = 0;
let labels = [];

const shuffle = arr => {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};

function selectColor() {
  const sel = $('targetColor').value;
  if (sel === 'random') {
    currentColorIndex = Math.floor(Math.random() * BASIC_COLORS.length);
  } else {
    currentColorIndex = parseInt(sel);
  }
  $('currentRuleDisplay').textContent = `Find the ${BASIC_COLORS[currentColorIndex].name.toUpperCase()} number`;
}

function generateRandomCode(length) {
  let code = '';
  for (let i = 0; i < length; i++) code += Math.floor(Math.random() * 10);
  return code;
}

function getRotatedBBox(textW, textH, angle) {
  const cos = Math.abs(Math.cos(angle));
  const sin = Math.abs(Math.sin(angle));
  return {
    w: textW * cos + textH * sin,
    h: textW * sin + textH * cos
  };
}

function generateLabels() {
  const codeStr = $('code').value || '1234';
  const numLabels = +$('labelCount').value;
  const targetCount = Math.min(+$('targetColorCount').value, Math.floor(numLabels / 2));
  const jitterPct = +$('jitter').value / 100;
  const rotationVar = +$('rotation').value;
  const W = +$('w').value;
  const H = +$('h').value;
  const isVisual = $('questionStyle').value === 'visual';

  const labelSizePct = +$('labelSize').value / 100;
  const fontSize = H * labelSizePct;

  // Reserve space for question area
  const questionHeight = isVisual ? H * 0.10 : 0;
  const ruleHeight = isVisual ? 0 : H * 0.12;
  const margin = Math.max(W, H) * 0.03;

  const areaTop = ruleHeight > 0 ? ruleHeight + margin * 0.5 : margin;
  const areaBottom = H - (isVisual ? questionHeight + margin * 0.3 : margin);
  const areaLeft = margin;
  const areaRight = W - margin;
  const areaWidth = areaRight - areaLeft;
  const areaHeight = areaBottom - areaTop;

  // Estimate max label bounding box for grid sizing
  // Use a rough estimate: 4-digit code ~ 4 * 0.6 * fontSize wide, fontSize tall
  const estTextW = codeStr.length * fontSize * 0.65;
  const maxAngle = rotationVar * Math.PI / 180;
  const maxBBox = getRotatedBBox(estTextW, fontSize, maxAngle);

  // Calculate grid so each cell fits the max label bounding box
  const cols = Math.max(1, Math.floor(areaWidth / (maxBBox.w * 1.15)));
  const rows = Math.max(1, Math.ceil(numLabels / cols));
  const cellW = areaWidth / cols;
  const cellH = areaHeight / rows;

  // Generate grid positions with jitter and edge clamping
  const halfLabelW = maxBBox.w / 2 + 2;
  const halfLabelH = maxBBox.h / 2 + 2;
  const positions = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const baseX = areaLeft + c * cellW + cellW / 2;
      const baseY = areaTop + r * cellH + cellH / 2;

      // Reduce jitter for edge cells
      const edgeFactorX = Math.min(1, Math.min(c, cols - 1 - c) / 1.5 + 0.3);
      const edgeFactorY = Math.min(1, Math.min(r, rows - 1 - r) / 1.5 + 0.3);
      const jX = (Math.random() - 0.5) * cellW * jitterPct * edgeFactorX;
      const jY = (Math.random() - 0.5) * cellH * jitterPct * edgeFactorY;

      // Clamp to keep label fully inside canvas
      let x = baseX + jX;
      let y = baseY + jY;
      x = Math.max(halfLabelW, Math.min(W - halfLabelW, x));
      y = Math.max(areaTop + halfLabelH, Math.min(areaBottom - halfLabelH, y));

      positions.push({ x, y });
    }
  }
  shuffle(positions);

  // Generate distractor codes (all unique, different from answer)
  const distractorValues = new Set();
  while (distractorValues.size < numLabels - 1) {
    const val = generateRandomCode(codeStr.length);
    if (val !== codeStr) distractorValues.add(val);
  }
  const distractors = Array.from(distractorValues);

  // Non-target colors, distributed evenly by cycling
  const otherColors = BASIC_COLORS.map((_, i) => i).filter(i => i !== currentColorIndex);

  labels = [];

  // 1 answer label (target color, correct code)
  labels.push({
    value: codeStr,
    x: positions[0].x,
    y: positions[0].y,
    rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
    colorIndex: currentColorIndex,
    isAnswer: true
  });

  // (targetCount - 1) decoy labels in target color, wrong codes
  for (let i = 1; i < targetCount; i++) {
    labels.push({
      value: distractors[i - 1],
      x: positions[i].x,
      y: positions[i].y,
      rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
      colorIndex: currentColorIndex,
      isAnswer: false
    });
  }

  // Remaining labels use non-target colors, cycled evenly
  for (let i = targetCount; i < Math.min(numLabels, positions.length); i++) {
    labels.push({
      value: distractors[i - 1],
      x: positions[i].x,
      y: positions[i].y,
      rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
      colorIndex: otherColors[(i - targetCount) % otherColors.length],
      isAnswer: false
    });
  }

  shuffle(labels);
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;

  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  if (labels.length === 0) generateLabels();

  const labelSizePct = +$('labelSize').value / 100;
  const fontSize = H * labelSizePct;
  const isVisual = $('questionStyle').value === 'visual';

  if (!isVisual) {
    // Text mode: draw rule text at top
    const ruleAreaHeight = H * 0.12;
    ctx.fillStyle = '#333';
    ctx.font = `bold ${ruleAreaHeight * 0.5}px system-ui, -apple-system, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(
      `Find the ${BASIC_COLORS[currentColorIndex].name.toUpperCase()} number`,
      W / 2, ruleAreaHeight / 2
    );
    // Separator
    ctx.beginPath();
    ctx.moveTo(W * 0.05, ruleAreaHeight);
    ctx.lineTo(W * 0.95, ruleAreaHeight);
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  // Draw labels
  ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (const label of labels) {
    ctx.save();
    ctx.translate(label.x, label.y);
    ctx.rotate(label.rotation);
    ctx.fillStyle = BASIC_COLOR_HEX[label.colorIndex];
    ctx.fillText(label.value, 0, 0);
    ctx.restore();
  }

  if (isVisual) {
    // Visual mode: draw "(colored circle) ‚Äì ?" at the bottom
    const qHeight = H * 0.10;
    const qY = H - qHeight / 2;
    const circleR = qHeight * 0.28;
    const dashGap = circleR * 1.2;
    const qFontSize = qHeight * 0.45;

    // Measure to center the whole thing: circle + gap + dash + gap + ?
    ctx.font = `bold ${qFontSize}px system-ui, -apple-system, sans-serif`;
    const dashW = ctx.measureText('‚Äì').width;
    const qW = ctx.measureText('?').width;
    const totalW = circleR * 2 + dashGap + dashW + dashGap + qW;
    const startX = W / 2 - totalW / 2 + circleR;

    // Separator above question area
    const sepY = H - qHeight - 2;
    ctx.beginPath();
    ctx.moveTo(W * 0.1, sepY);
    ctx.lineTo(W * 0.9, sepY);
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Colored circle
    ctx.beginPath();
    ctx.arc(startX, qY, circleR, 0, Math.PI * 2);
    ctx.fillStyle = BASIC_COLOR_HEX[currentColorIndex];
    ctx.fill();

    // Dash
    ctx.fillStyle = '#555';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText('‚Äì', startX + circleR + dashGap * 0.3, qY);

    // Question mark
    ctx.fillText('?', startX + circleR + dashGap * 0.3 + dashW + dashGap * 0.5, qY);
  }
}

// Event handlers
function randCode() {
  const numDigits = ($('code').value || '').length || 4;
  $('code').value = generateRandomCode(numDigits);
  generateLabels();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => {
    if (b.dataset.t === 'code') { randCode(); draw(); }
  };
});

$('newRule').onclick = () => { selectColor(); generateLabels(); draw(); };
$('targetColor').onchange = () => { selectColor(); generateLabels(); draw(); };

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    el.value = DEF[k];
  }
  // Update range display spans
  document.querySelectorAll('input[type=range]').forEach(r => {
    const span = r.nextElementSibling;
    if (span && span.tagName === 'SPAN') span.textContent = r.value;
  });
  selectColor();
  generateLabels();
  draw();
};

$('rerender').onclick = () => { generateLabels(); draw(); };

$('code').oninput = () => { generateLabels(); draw(); };
$('labelCount').oninput = () => { generateLabels(); draw(); };
$('targetColorCount').oninput = () => { generateLabels(); draw(); };
$('jitter').oninput = () => { generateLabels(); draw(); };
$('rotation').oninput = () => { generateLabels(); draw(); };
$('labelSize').oninput = () => { generateLabels(); draw(); };
$('questionStyle').onchange = () => { generateLabels(); draw(); };
$('w').oninput = () => { generateLabels(); draw(); };
$('h').oninput = () => { generateLabels(); draw(); };

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};

// Initial setup
selectColor();
generateLabels();
draw();

</script>
