<!doctype html>
<meta charset="utf-8">
<title>Label Haystack (Color) â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=600 min=100></label>

<!-- === code + ğŸ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ğŸ²</button>

<hr>

<!-- === visual settings === -->
<label>Number of labels
  <input id=labelCount type=range min=15 max=100 step=1 value=50>
</label><br>

<label>Label size (% of height)
  <input id=labelSize type=range min=3 max=15 step=1 value=11>
</label><br>

<label>Rotation variance (degrees)
  <input id=rotation type=range min=0 max=30 step=1 value=20>
</label><br>

<label>Grid jitter (% of cell)
  <input id=jitter type=range min=0 max=40 step=1 value=30>
</label><br>

<label><input id=coloredDistractors type=checkbox> Colored distractors (non-overlapping with answer colors)</label><br>

<button id=reset type=button>ğŸ”„ Restore defaults</button>
<button id=rerender type=button>ğŸ” Re-render</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
// Display current value next to range inputs
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:4px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});
</script>
<script>

const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'label_haystack_color';

// Colors for answer digits (up to 5 digits = 5 colors)
const DIGIT_COLORS = [
  '#E00000', // Red
  '#0000DD', // Blue
  '#008800', // Green
  '#DDAA00', // Yellow (adjusted for clarity)
  '#CC00CC', // Purple
];

// Grey for distractors
const DISTRACTOR_COLOR = '#AAAAAA';

// Extra colors for colored distractors (visually distinct from DIGIT_COLORS)
const DISTRACTOR_PALETTE = [
  '#FF8800', // Orange
  '#00BBBB', // Teal
  '#8855DD', // Violet
  '#BB5577', // Rose
  '#558833', // Olive
  '#AA7744', // Brown
  '#6688CC', // Steel blue
  '#CC6699', // Pink
  '#44AA99', // Seafoam
  '#887766', // Taupe
];

const DEF = {
  w: 800, h: 600, code: '1234',
  labelCount: 50, labelSize: 11, rotation: 20, jitter: 30,
  coloredDistractors: false
};

let labels = [];

const shuffle = arr => {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
};

function generateRandomCode(length) {
  let code = '';
  for (let i = 0; i < length; i++) code += Math.floor(Math.random() * 10);
  return code;
}

function getRotatedBBox(textW, textH, angle) {
  const cos = Math.abs(Math.cos(angle));
  const sin = Math.abs(Math.sin(angle));
  return {
    w: textW * cos + textH * sin,
    h: textW * sin + textH * cos
  };
}

function generateLabels() {
  const codeStr = $('code').value || '1234';
  const digits = codeStr.split('');
  const numLabels = Math.max(+$('labelCount').value, digits.length + 5);
  const jitterPct = +$('jitter').value / 100;
  const rotationVar = +$('rotation').value;
  const W = +$('w').value;
  const H = +$('h').value;

  const labelSizePct = +$('labelSize').value / 100;
  const fontSize = H * labelSizePct;

  // Reserve space for question area at the bottom
  const questionHeight = H * 0.12;
  const margin = Math.max(W, H) * 0.03;

  const areaTop = margin;
  const areaBottom = H - questionHeight - margin * 0.3;
  const areaLeft = margin;
  const areaRight = W - margin;
  const areaWidth = areaRight - areaLeft;
  const areaHeight = areaBottom - areaTop;

  // Estimate max label bounding box for grid sizing (single digit)
  const estTextW = fontSize * 0.7;
  const maxAngle = rotationVar * Math.PI / 180;
  const maxBBox = getRotatedBBox(estTextW, fontSize, maxAngle);

  // Calculate grid so each cell fits the max label bounding box
  const cols = Math.max(1, Math.floor(areaWidth / (maxBBox.w * 1.3)));
  const rows = Math.max(1, Math.ceil(numLabels / cols));
  const cellW = areaWidth / cols;
  const cellH = areaHeight / rows;

  // Generate grid positions with jitter and edge clamping
  const halfLabelW = maxBBox.w / 2 + 2;
  const halfLabelH = maxBBox.h / 2 + 2;
  const positions = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const baseX = areaLeft + c * cellW + cellW / 2;
      const baseY = areaTop + r * cellH + cellH / 2;

      const edgeFactorX = Math.min(1, Math.min(c, cols - 1 - c) / 1.5 + 0.3);
      const edgeFactorY = Math.min(1, Math.min(r, rows - 1 - r) / 1.5 + 0.3);
      const jX = (Math.random() - 0.5) * cellW * jitterPct * edgeFactorX;
      const jY = (Math.random() - 0.5) * cellH * jitterPct * edgeFactorY;

      let x = baseX + jX;
      let y = baseY + jY;
      x = Math.max(halfLabelW, Math.min(W - halfLabelW, x));
      y = Math.max(areaTop + halfLabelH, Math.min(areaBottom - halfLabelH, y));

      positions.push({ x, y });
    }
  }
  shuffle(positions);

  labels = [];

  // Answer labels: one per digit, each with a unique color
  for (let i = 0; i < digits.length; i++) {
    labels.push({
      value: digits[i],
      x: positions[i].x,
      y: positions[i].y,
      rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
      color: DIGIT_COLORS[i],
      isAnswer: true
    });
  }

  // Distractor labels: random single digits, grey or colored
  const useColoredDistractors = $('coloredDistractors').checked;
  const numDistractors = Math.min(numLabels - digits.length, positions.length - digits.length);
  for (let i = 0; i < numDistractors; i++) {
    let color = DISTRACTOR_COLOR;
    if (useColoredDistractors) {
      color = DISTRACTOR_PALETTE[Math.floor(Math.random() * DISTRACTOR_PALETTE.length)];
    }
    labels.push({
      value: String(Math.floor(Math.random() * 10)),
      x: positions[digits.length + i].x,
      y: positions[digits.length + i].y,
      rotation: (Math.random() - 0.5) * 2 * rotationVar * Math.PI / 180,
      color,
      isAnswer: false
    });
  }

  shuffle(labels);
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;

  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  if (labels.length === 0) generateLabels();

  const labelSizePct = +$('labelSize').value / 100;
  const fontSize = H * labelSizePct;
  const codeStr = $('code').value || '1234';
  const digits = codeStr.split('');

  // Draw labels
  ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (const label of labels) {
    ctx.save();
    ctx.translate(label.x, label.y);
    ctx.rotate(label.rotation);
    ctx.fillStyle = label.color;
    ctx.fillText(label.value, 0, 0);
    ctx.restore();
  }

  // Question area: N colored circles with "?" below each
  const qHeight = H * 0.12;
  const qY = H - qHeight / 2;
  const circleR = qHeight * 0.22;
  const qFontSize = qHeight * 0.35;

  // Separator above question area
  const sepY = H - qHeight - 2;
  ctx.beginPath();
  ctx.moveTo(W * 0.1, sepY);
  ctx.lineTo(W * 0.9, sepY);
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Layout: evenly space N groups of (circle + ?)
  const groupSpacing = Math.min(W * 0.15, W / (digits.length + 1));
  const totalGroupW = groupSpacing * (digits.length - 1);
  const startX = W / 2 - totalGroupW / 2;

  ctx.font = `bold ${qFontSize}px system-ui, -apple-system, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < digits.length; i++) {
    const gx = startX + i * groupSpacing;

    // Colored circle
    ctx.beginPath();
    ctx.arc(gx, qY - circleR * 0.6, circleR, 0, Math.PI * 2);
    ctx.fillStyle = DIGIT_COLORS[i];
    ctx.fill();

    // Question mark below circle
    ctx.fillStyle = '#555';
    ctx.fillText('?', gx, qY + circleR * 1.4);
  }
}

// Event handlers
function randCode() {
  const numDigits = ($('code').value || '').length || 4;
  $('code').value = generateRandomCode(numDigits);
  generateLabels();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => {
    if (b.dataset.t === 'code') { randCode(); draw(); }
  };
});

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    if (el.type === 'checkbox') { el.checked = DEF[k]; continue; }
    el.value = DEF[k];
  }
  document.querySelectorAll('input[type=range]').forEach(r => {
    const span = r.nextElementSibling;
    if (span && span.tagName === 'SPAN') span.textContent = r.value;
  });
  generateLabels();
  draw();
};

$('rerender').onclick = () => { generateLabels(); draw(); };

$('code').oninput = () => { generateLabels(); draw(); };
$('labelCount').oninput = () => { generateLabels(); draw(); };
$('jitter').oninput = () => { generateLabels(); draw(); };
$('rotation').oninput = () => { generateLabels(); draw(); };
$('labelSize').oninput = () => { generateLabels(); draw(); };
$('w').oninput = () => { generateLabels(); draw(); };
$('h').oninput = () => { generateLabels(); draw(); };
$('coloredDistractors').onchange = () => { generateLabels(); draw(); };

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};

// Initial setup
generateLabels();
draw();

</script>
