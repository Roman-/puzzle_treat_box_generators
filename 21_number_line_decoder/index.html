<!doctype html>
<meta charset="utf-8">
<title>Number Line Drop Lines â€“ generator</title>

<!-- === size first === -->
<label>W <input id=w type=number value=800 min=50></label>
<label>H <input id=h type=number value=600 min=50></label>

<!-- === code (3â€“5 digits) + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === creativity controls === -->
<label title="0 = hide that number, 1 = show">Mask <input id=mask type=text value="1111111111" maxlength=10 style="width:100px;font-family:monospace" title="0 = hide that number, 1 = show"></label>
<br>
<label>Line Y <input id=lineY type=range min=0.15 max=0.40 step=0.01 value=0.15></label>
<br>
<label>Line thickness <input id=lineW type=range min=1 max=20 step=1 value=3></label>
<br>
<label>Tick height <input id=tickH type=range min=0.01 max=0.06 step=0.005 value=0.03></label>
<br>
<label>Label font size <input id=labelFont type=range min=0.02 max=0.25 step=0.005 value=0.06></label>
<br>
<label>Dot radius <input id=dotR type=range min=0.005 max=0.025 step=0.002 value=0.012></label>
<br>
<label>? size <input id=qSize type=range min=0.03 max=0.1 step=0.005 value=0.075></label>
<br>
<label>Palette <select id=palette>
  <option value=bright>bright</option>
  <option value=pastel>pastel</option>
  <option value=warm>warm</option>
  <option value=cool>cool</option>
  <option value=neon>neon</option>
</select></label>

<br>
<label>Line path <select id=linePath>
  <option value=smooth>smooth</option>
  <option value=wavy>wavy</option>
  <option value=zigzag>zigzag</option>
</select></label>
<br>
<label>Wave frequency <input id=waveFreq type=range min=1 max=10 step=1 value=4></label>
<br>
<label>Wave amplitude <input id=waveAmp type=range min=0.01 max=0.10 step=0.01 value=0.03></label>
<br>
<label><input id=varyThickness type=checkbox> Vary thickness</label>
<br>
<label>Min thickness <input id=minThick type=range min=1 max=5 step=0.5 value=1></label>
<br>
<label>Max thickness <input id=maxThick type=range min=5 max=20 step=0.5 value=8></label>

<br>
<label>Bottom layout <select id=bottomLayout>
  <option value=straight>straight</option>
  <option value=arc-up>arc-up</option>
  <option value=arc-down>arc-down</option>
</select></label>
<br>
<label>Marker style <select id=markerStyle>
  <option value=none>none</option>
  <option value=filled selected>filled</option>
  <option value=ring>ring</option>
  <option value=star>star</option>
  <option value=x-mark>x-mark</option>
  <option value=diamond>diamond</option>
</select></label>

<br>
<button id=reset type=button>ðŸ”„ Restore defaults</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
// Display current value next to range inputs
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:1px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});
</script>
<script>
  const $ = id => document.getElementById(id);
  const ctx = $('can').getContext('2d');
  const NAME = 'number_line_drop';

  const PALETTES = {
    bright: ['#ff4040','#4090ff','#00aa40','#ffd800','#ff8c00','#9b59b6','#e91e90','#00bcd4'],
    pastel: ['#ffb3ba','#bae1ff','#baffc9','#ffffba','#e8baff','#ffd9ba','#baffee','#ffbadc'],
    warm:   ['#ff4040','#ff8c00','#ffd800','#ff6b6b','#e74c3c','#f39c12','#d35400','#c0392b'],
    cool:   ['#4090ff','#00aa40','#00bcd4','#9b59b6','#3498db','#1abc9c','#2ecc71','#8e44ad'],
    neon:   ['#ff0080','#00ff80','#8000ff','#ff8000','#0080ff','#80ff00','#ff0040','#40ff00']
  };

  function seededShuffle(arr, seed) {
    const a = [...arr]; let s = Math.abs(seed) || 1;
    for (let i = a.length - 1; i > 0; i--) {
      s = (s * 1103515245 + 12345) & 0x7fffffff;
      const j = s % (i + 1);
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  const DEF = {
    w: 800, h: 600, code: '1234',
    mask: '1111111111', lineY: 0.15, lineW: 3,
    tickH: 0.03, labelFont: 0.06, dotR: 0.012,
    qSize: 0.075, palette: 'bright',
    linePath: 'smooth', waveFreq: 4, waveAmp: 0.03,
    varyThickness: false, minThick: 1, maxThick: 8,
    bottomLayout: 'straight',
    markerStyle: 'filled'
  };

  // --- Bezier helpers ---

  function quadBezierPoint(p0x, p0y, cpx, cpy, p1x, p1y, t) {
    const u = 1 - t;
    return {
      x: u * u * p0x + 2 * u * t * cpx + t * t * p1x,
      y: u * u * p0y + 2 * u * t * cpy + t * t * p1y
    };
  }

  function quadBezierTangent(p0x, p0y, cpx, cpy, p1x, p1y, t) {
    const u = 1 - t;
    return {
      x: 2 * u * (cpx - p0x) + 2 * t * (p1x - cpx),
      y: 2 * u * (cpy - p0y) + 2 * t * (p1y - cpy)
    };
  }

  function triangleWave(t) {
    const p = t / (2 * Math.PI);
    const frac = p - Math.floor(p);
    if (frac < 0.25) return frac * 4;
    if (frac < 0.75) return 2 - frac * 4;
    return frac * 4 - 4;
  }

  // --- Marker helpers ---

  function drawStar(cx, cy, r, color) {
    const outerR = r * 1.3, innerR = outerR * 0.4;
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < 10; i++) {
      const rad = (i * Math.PI / 5) - Math.PI / 2;
      const radius = i % 2 === 0 ? outerR : innerR;
      const x = cx + Math.cos(rad) * radius;
      const y = cy + Math.sin(rad) * radius;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
  }

  function drawXMark(cx, cy, r, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(1.5, r * 0.45);
    ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(cx - r, cy - r); ctx.lineTo(cx + r, cy + r); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx + r, cy - r); ctx.lineTo(cx - r, cy + r); ctx.stroke();
  }

  function drawDiamond(cx, cy, r, color) {
    const s = r * 1.2;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(cx, cy - s);
    ctx.lineTo(cx + s, cy);
    ctx.lineTo(cx, cy + s);
    ctx.lineTo(cx - s, cy);
    ctx.closePath();
    ctx.fill();
  }

  function drawMarker(style, cx, cy, r, color) {
    if (style === 'none') return;
    ctx.save();
    if (style === 'filled') {
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
    } else if (style === 'ring') {
      ctx.strokeStyle = color;
      ctx.lineWidth = Math.max(1.5, r * 0.4);
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill(); ctx.stroke();
    } else if (style === 'star') {
      drawStar(cx, cy, r, color);
    } else if (style === 'x-mark') {
      drawXMark(cx, cy, r, color);
    } else if (style === 'diamond') {
      drawDiamond(cx, cy, r, color);
    }
    ctx.restore();
  }

  // --- Main draw ---

  function draw(){
    const W = +$('w').value, H = +$('h').value;
    $('can').width = W; $('can').height = H;
    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);

    const codeVal = $('code').value.replace(/\D/g,'') || '1234';
    const N = Math.max(3, Math.min(5, codeVal.length));
    const digitsArr = codeVal.padEnd(N,'0').slice(0,N).split('').map(Number);

    const rawMask = $('mask').value;
    const mask = (rawMask + '0000000000').slice(0, 10);

    // Sizes from controls
    const lineYFrac   = +$('lineY').value;
    const lineWPx     = +$('lineW').value * (W / 800);
    const tickHPx     = +$('tickH').value * H;
    const labelFontPx = +$('labelFont').value * H;
    const dotRPx      = +$('dotR').value * Math.min(W, H);
    const qSizePx     = +$('qSize').value * Math.min(W, H);
    const palName     = $('palette').value;

    // Line styling
    const linePathMode = $('linePath').value;
    const waveFreq     = +$('waveFreq').value;
    const waveAmp      = +$('waveAmp').value * Math.min(W, H);
    const useVaryThick = $('varyThickness').checked;
    const minThick     = +$('minThick').value;
    const maxThick     = +$('maxThick').value;

    // Bottom & markers
    const bottomLayout = $('bottomLayout').value;
    const arcCurve     = 0.05; // fixed curvature when arc selected
    const markerStyle  = $('markerStyle').value;

    // Colors: seeded shuffle
    const seed = digitsArr.reduce((a, d, i) => a + d * Math.pow(10, i), 0) || 1;
    const colors = seededShuffle(PALETTES[palName] || PALETTES.bright, seed);

    // Layout
    const marginX = W * 0.08;
    const lineY = lineYFrac * H;
    const lineX1 = marginX;
    const lineX2 = W - marginX;
    const lineLen = lineX2 - lineX1;

    // ---- Draw number line ----
    ctx.strokeStyle = '#333';
    ctx.lineWidth = lineWPx;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(lineX1, lineY);
    ctx.lineTo(lineX2, lineY);
    ctx.stroke();

    // Tick positions (0â€“9)
    const tickX = [];
    for (let i = 0; i < 10; i++) {
      tickX.push(lineX1 + (i / 9) * lineLen);
    }

    // ---- Draw ticks ----
    ctx.strokeStyle = '#333';
    ctx.lineWidth = Math.max(1, lineWPx * 0.6);
    for (let i = 0; i < 10; i++) {
      ctx.beginPath();
      ctx.moveTo(tickX[i], lineY - tickHPx);
      ctx.lineTo(tickX[i], lineY + tickHPx);
      ctx.stroke();
    }

    // ---- Draw labels ----
    ctx.fillStyle = '#222';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.font = `bold ${labelFontPx}px sans-serif`;
    for (let i = 0; i < 10; i++) {
      if (mask[i] === '1') {
        ctx.fillText(String(i), tickX[i], lineY - tickHPx - labelFontPx * 0.15);
      }
    }

    // ---- Question mark positions at bottom ----
    const qY = H * 0.85;
    const qSpacing = lineLen / (N + 1);
    const qCenters = [];
    for (let j = 0; j < N; j++) {
      let cx = lineX1 + qSpacing * (j + 1);
      let cy = qY;
      if (bottomLayout !== 'straight') {
        const mid = (N - 1) / 2;
        const normDist = (j - mid) / (mid || 1);
        const offset = arcCurve * H * (1 - normDist * normDist);
        if (bottomLayout === 'arc-up') cy += offset;
        else                           cy -= offset;
      }
      qCenters.push({ x: cx, y: cy });
    }

    // ---- Draw connector lines ----
    const baseConnW = Math.max(2, lineWPx * 0.8);
    ctx.lineCap = 'round';

    for (let j = 0; j < N; j++) {
      const col = colors[j % colors.length];
      const fromX = qCenters[j].x;
      const fromY = qCenters[j].y - qSizePx;
      const toX = tickX[digitsArr[j]];
      const toY = lineY;

      const cpX = (fromX + toX) / 2;
      const cpY = (fromY + toY) / 2 - Math.abs(fromX - toX) * 0.15;

      // Determine line width
      let connW = baseConnW;
      if (useVaryThick) {
        connW = N === 1 ? (minThick + maxThick) / 2
              : minThick + (maxThick - minThick) * (j / (N - 1));
      }
      ctx.lineWidth = connW;
      ctx.strokeStyle = col;

      if (linePathMode === 'smooth') {
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        ctx.quadraticCurveTo(cpX, cpY, toX, toY);
        ctx.stroke();
      } else {
        const numSamples = 50;
        ctx.beginPath();
        for (let s = 0; s <= numSamples; s++) {
          const t = s / numSamples;
          const pt = quadBezierPoint(fromX, fromY, cpX, cpY, toX, toY, t);
          const tan = quadBezierTangent(fromX, fromY, cpX, cpY, toX, toY, t);

          const tanLen = Math.sqrt(tan.x * tan.x + tan.y * tan.y) || 1;
          const nx = -tan.y / tanLen;
          const ny = tan.x / tanLen;

          let offset = 0;
          if (linePathMode === 'wavy') {
            offset = Math.sin(t * waveFreq * 2 * Math.PI) * waveAmp;
          } else {
            offset = triangleWave(t * waveFreq * 2 * Math.PI) * waveAmp;
          }

          const px = pt.x + nx * offset;
          const py = pt.y + ny * offset;

          if (s === 0) ctx.moveTo(px, py);
          else         ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
    }


    // ---- Draw connection markers on number line ----
    for (let j = 0; j < N; j++) {
      const col = colors[j % colors.length];
      drawMarker(markerStyle, tickX[digitsArr[j]], lineY, dotRPx, col);
    }

    // ---- Draw "?" circles at the bottom ----
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    for (let j = 0; j < N; j++) {
      const col = colors[j % colors.length];
      ctx.fillStyle = col;
      ctx.beginPath();
      ctx.arc(qCenters[j].x, qCenters[j].y, qSizePx, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#fff';
      ctx.font = `bold ${qSizePx * 1.2}px sans-serif`;
      ctx.fillText('?', qCenters[j].x, qCenters[j].y);
    }
  }

  oninput = draw;

  ['linePath','bottomLayout','markerStyle','palette'].forEach(id => {
    $(id).addEventListener('change', draw);
  });
  $('varyThickness').addEventListener('change', draw);

  draw();

  function randCode(){
    const n = Math.max(3, Math.min(5, ($('code').value.replace(/\D/g,'') || '1234').length));
    const max = Math.pow(10, n);
    $('code').value = (Math.random()*max|0).toString().padStart(n,'0');
  }

  document.querySelectorAll('[data-t]').forEach(b => b.onclick = () => { if(b.dataset.t==='code'){ randCode(); draw(); } });

  $('reset').onclick = () => {
    for (const k in DEF){
      const el = $(k);
      if (!el) continue;
      if (el.type === 'checkbox') el.checked = DEF[k];
      else                        el.value   = DEF[k];
    }
    document.querySelectorAll('input[type=range]').forEach(r => {
      const span = r.nextElementSibling;
      if (span && span.tagName === 'SPAN') span.textContent = r.value;
    });
    draw();
  };

  $('can').onclick = () => {
    const codeVal = $('code').value.replace(/\D/g,'') || '1234';
    const n = Math.max(3, Math.min(5, codeVal.length));
    const c = codeVal.padEnd(n,'0').slice(0,n);
    const a = document.createElement('a');
    a.download = `${NAME}_${c}.png`;
    a.href = $('can').toDataURL();
    a.click();
    randCode(); draw();
  };
</script>
