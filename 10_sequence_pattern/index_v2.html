<!doctype html>
<meta charset="utf-8">
<title>Sequence Pattern (Columns) â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=500 min=100></label>
<label>H <input id=h type=number value=500 min=100></label>

<!-- === 4-digit code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === creativity === -->
<label>Pattern type
  <select id=patternType>
    <option value="countdown" selected>Countdown (-1)</option>
    <option value="countup">Count up (+1)</option>
    <option value="skip2down">Skip 2 down (-2)</option>
    <option value="skip2up">Skip 2 up (+2)</option>
    <option value="random">Random per column</option>
  </select>
</label><br>

<label>Min steps shown
  <input id=minSteps type=range min=2 max=8 step=1 value=3>
</label><br>

<label>Random extra steps
  <input id=extraSteps type=range min=0 max=4 step=1 value=2>
</label><br>

<label>Element style
  <select id=elemStyle>
    <option value="plain" selected>Plain digits</option>
    <option value="circle">Circles</option>
    <option value="square">Squares</option>
  </select>
</label><br>

<label>Element size (% of cell)
  <input id=elemSize type=range min=40 max=95 step=5 value=70>
</label><br>

<label>Column spacing
  <input id=colSpacing type=range min=10 max=60 step=5 value=30>
</label><br>

<label>Row spacing
  <input id=rowSpacing type=range min=5 max=40 step=5 value=15>
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'sequence_pattern_columns';

const DEF = {
  w: 500, h: 500, code: '1234',
  patternType: 'countdown', minSteps: 3, extraSteps: 2,
  elemStyle: 'plain', elemSize: 70,
  colSpacing: 30, rowSpacing: 15
};

// Store random values for each column (pattern type and extra steps)
let columnPatterns = [];
let columnExtraSteps = [];
const PATTERN_TYPES = ['countdown', 'countup', 'skip2down', 'skip2up'];

// Generate sequence leading to target digit (does NOT include target itself)
function generateSequence(target, patternType, steps) {
  const seq = [];
  let current = target;

  // Build sequence backwards from target, NOT including target
  for (let i = 0; i < steps; i++) {
    // First, step backwards to get the previous value
    switch (patternType) {
      case 'countdown':
        current = (current + 1) % 10;  // Going backwards from countdown means +1
        break;
      case 'countup':
        current = (current - 1 + 10) % 10;  // Going backwards from countup means -1
        break;
      case 'skip2down':
        current = (current + 2) % 10;
        break;
      case 'skip2up':
        current = (current - 2 + 10) % 10;
        break;
    }
    seq.unshift(current);
  }

  return seq;
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;

  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  const code = $('code').value || '1234';
  const digits = code.split('').map(Number);
  const numCols = digits.length;
  const patternType = $('patternType').value;
  const minSteps = +$('minSteps').value;
  const extraSteps = +$('extraSteps').value;
  const elemStyle = $('elemStyle').value;
  const elemSizePct = +$('elemSize').value / 100;
  const colSpacing = +$('colSpacing').value;
  const rowSpacing = +$('rowSpacing').value;

  // Ensure we have random values for each column
  while (columnPatterns.length < numCols) {
    columnPatterns.push(PATTERN_TYPES[Math.floor(Math.random() * PATTERN_TYPES.length)]);
  }
  while (columnExtraSteps.length < numCols) {
    columnExtraSteps.push(Math.floor(Math.random() * (extraSteps + 1)));
  }

  // Calculate steps for each column
  const colSteps = digits.map((_, col) => minSteps + columnExtraSteps[col]);
  const maxSteps = Math.max(...colSteps);
  const numRows = maxSteps + 1; // max steps visible + 1 answer row

  // Calculate cell size
  const availableW = W - (numCols + 1) * colSpacing;
  const availableH = H - (numRows + 1) * rowSpacing;
  const cellW = availableW / numCols;
  const cellH = availableH / numRows;
  const cellSize = Math.min(cellW, cellH);
  const elemSize = cellSize * elemSizePct;

  // Center the grid
  const gridW = numCols * cellSize + (numCols - 1) * colSpacing;
  const gridH = numRows * cellSize + (numRows - 1) * rowSpacing;
  const startX = (W - gridW) / 2;
  const startY = (H - gridH) / 2;

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Generate sequences for each column
  const sequences = digits.map((d, col) => {
    const pattern = patternType === 'random' ? columnPatterns[col] : patternType;
    return generateSequence(d, pattern, colSteps[col]);
  });

  // Draw each cell
  for (let col = 0; col < numCols; col++) {
    const seq = sequences[col];
    const stepsForCol = colSteps[col];
    // Calculate starting row for this column (offset to align at bottom)
    const startRow = maxSteps - stepsForCol;

    for (let row = 0; row < numRows; row++) {
      const isAnswerRow = (row === numRows - 1);
      const seqIndex = row - startRow;
      const hasValue = seqIndex >= 0 && seqIndex < stepsForCol;

      // Skip cells above where this column starts (except answer row)
      if (!isAnswerRow && !hasValue) continue;

      const x = startX + col * (cellSize + colSpacing) + cellSize / 2;
      const y = startY + row * (cellSize + rowSpacing) + cellSize / 2;

      const value = isAnswerRow ? '?' : seq[seqIndex].toString();

      // Draw element based on style
      if (elemStyle === 'circle') {
        ctx.beginPath();
        ctx.arc(x, y, elemSize / 2, 0, Math.PI * 2);
        ctx.fillStyle = isAnswerRow ? '#f0f0f0' : '#fff';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (elemStyle === 'square') {
        ctx.fillStyle = isAnswerRow ? '#f0f0f0' : '#fff';
        ctx.fillRect(x - elemSize / 2, y - elemSize / 2, elemSize, elemSize);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.strokeRect(x - elemSize / 2, y - elemSize / 2, elemSize, elemSize);
      }

      // Draw value
      const fontSize = elemStyle === 'plain' ? elemSize : elemSize * 0.6;
      ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
      ctx.fillStyle = isAnswerRow ? '#666' : '#333';
      ctx.fillText(value, x, y);
    }
  }

  // Draw column separators (light vertical lines)
  if (numCols > 1) {
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    for (let col = 1; col < numCols; col++) {
      const x = startX + col * (cellSize + colSpacing) - colSpacing / 2;
      ctx.beginPath();
      ctx.moveTo(x, startY - 10);
      ctx.lineTo(x, startY + gridH + 10);
      ctx.stroke();
    }
  }

  // Draw answer row indicator
  const answerY = startY + (numRows - 1) * (cellSize + rowSpacing) - rowSpacing / 2;
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(startX - 20, answerY);
  ctx.lineTo(startX + gridW + 20, answerY);
  ctx.stroke();
  ctx.setLineDash([]);
}

// Randomize column-specific values
function randomizeColumns() {
  const code = $('code').value || '1234';
  const numCols = code.length;
  const extraSteps = +$('extraSteps').value;

  columnPatterns = [];
  columnExtraSteps = [];
  for (let i = 0; i < numCols; i++) {
    columnPatterns.push(PATTERN_TYPES[Math.floor(Math.random() * PATTERN_TYPES.length)]);
    columnExtraSteps.push(Math.floor(Math.random() * (extraSteps + 1)));
  }
}

// Event handlers
function randCode() {
  const len = Math.min(5, Math.max(1, ($('code').value || '').length || 4));
  const max = Math.pow(10, len);
  $('code').value = (Math.random() * max | 0).toString().padStart(len, '0');
  randomizeColumns();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => { if(b.dataset.t==='code'){ randCode(); draw(); } };
});

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    el.value = DEF[k];
  }
  randomizeColumns();
  draw();
};

// Re-randomize extra steps when extraSteps slider changes
$('extraSteps').oninput = () => { randomizeColumns(); draw(); };

// Re-randomize when code length changes
$('code').oninput = () => { randomizeColumns(); draw(); };

document.querySelectorAll('input, select').forEach(el => {
  if (!el.oninput) el.oninput = draw;
  if (!el.onchange) el.onchange = draw;
});

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};

// Initial
randomizeColumns();
draw();
</script>
