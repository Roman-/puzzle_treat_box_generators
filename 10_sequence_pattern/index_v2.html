<!doctype html>
<meta charset="utf-8">
<title>Sequence Pattern (Columns) â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=400 min=100></label>

<!-- === 4-digit code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === creativity === -->
<label>Pattern type
  <select id=patternType>
    <option value="countdown" selected>Countdown (-1)</option>
    <option value="countup">Count up (+1)</option>
    <option value="skip2down">Skip 2 down (-2)</option>
    <option value="skip2up">Skip 2 up (+2)</option>
  </select>
</label><br>

<label>Steps shown
  <input id=steps type=range min=3 max=6 step=1 value=4>
</label><br>

<label>Element style
  <select id=elemStyle>
    <option value="plain" selected>Plain digits</option>
    <option value="circle">Circles</option>
    <option value="square">Squares</option>
  </select>
</label><br>

<label>Element size (% of cell)
  <input id=elemSize type=range min=40 max=95 step=5 value=70>
</label><br>

<label>Column spacing
  <input id=colSpacing type=range min=10 max=60 step=5 value=30>
</label><br>

<label>Row spacing
  <input id=rowSpacing type=range min=5 max=40 step=5 value=15>
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'sequence_pattern_columns';

const DEF = {
  w: 800, h: 400, code: '1234',
  patternType: 'countdown', steps: 4,
  elemStyle: 'plain', elemSize: 70,
  colSpacing: 30, rowSpacing: 15
};

// Generate sequence leading to target digit
function generateSequence(target, patternType, steps) {
  const seq = [];
  let current = target;

  // Build sequence backwards from target
  for (let i = 0; i < steps; i++) {
    seq.unshift(current);
    switch (patternType) {
      case 'countdown':
        current = (current + 1) % 10;
        break;
      case 'countup':
        current = (current - 1 + 10) % 10;
        break;
      case 'skip2down':
        current = (current + 2) % 10;
        break;
      case 'skip2up':
        current = (current - 2 + 10) % 10;
        break;
    }
  }

  return seq;
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;

  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  const code = $('code').value || '1234';
  const digits = code.split('').map(Number);
  const numCols = digits.length;
  const patternType = $('patternType').value;
  const steps = +$('steps').value;
  const elemStyle = $('elemStyle').value;
  const elemSizePct = +$('elemSize').value / 100;
  const colSpacing = +$('colSpacing').value;
  const rowSpacing = +$('rowSpacing').value;

  const numRows = steps + 1; // steps visible + 1 answer row

  // Calculate cell size
  const availableW = W - (numCols + 1) * colSpacing;
  const availableH = H - (numRows + 1) * rowSpacing;
  const cellW = availableW / numCols;
  const cellH = availableH / numRows;
  const cellSize = Math.min(cellW, cellH);
  const elemSize = cellSize * elemSizePct;

  // Center the grid
  const gridW = numCols * cellSize + (numCols - 1) * colSpacing;
  const gridH = numRows * cellSize + (numRows - 1) * rowSpacing;
  const startX = (W - gridW) / 2;
  const startY = (H - gridH) / 2;

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Generate sequences for each column
  const sequences = digits.map(d => generateSequence(d, patternType, steps));

  // Draw each cell
  for (let col = 0; col < numCols; col++) {
    const seq = sequences[col];

    for (let row = 0; row < numRows; row++) {
      const isAnswerRow = (row === numRows - 1);
      const x = startX + col * (cellSize + colSpacing) + cellSize / 2;
      const y = startY + row * (cellSize + rowSpacing) + cellSize / 2;

      const value = isAnswerRow ? '?' : seq[row].toString();

      // Draw element based on style
      if (elemStyle === 'circle') {
        ctx.beginPath();
        ctx.arc(x, y, elemSize / 2, 0, Math.PI * 2);
        ctx.fillStyle = isAnswerRow ? '#f0f0f0' : '#fff';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (elemStyle === 'square') {
        ctx.fillStyle = isAnswerRow ? '#f0f0f0' : '#fff';
        ctx.fillRect(x - elemSize / 2, y - elemSize / 2, elemSize, elemSize);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.strokeRect(x - elemSize / 2, y - elemSize / 2, elemSize, elemSize);
      }

      // Draw value
      const fontSize = elemStyle === 'plain' ? elemSize : elemSize * 0.6;
      ctx.font = `bold ${fontSize}px system-ui, -apple-system, sans-serif`;
      ctx.fillStyle = isAnswerRow ? '#666' : '#333';
      ctx.fillText(value, x, y);
    }
  }

  // Draw column separators (light vertical lines)
  if (numCols > 1) {
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    for (let col = 1; col < numCols; col++) {
      const x = startX + col * (cellSize + colSpacing) - colSpacing / 2;
      ctx.beginPath();
      ctx.moveTo(x, startY - 10);
      ctx.lineTo(x, startY + gridH + 10);
      ctx.stroke();
    }
  }

  // Draw answer row indicator
  const answerY = startY + (numRows - 1) * (cellSize + rowSpacing) - rowSpacing / 2;
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1;
  ctx.setLineDash([5, 5]);
  ctx.beginPath();
  ctx.moveTo(startX - 20, answerY);
  ctx.lineTo(startX + gridW + 20, answerY);
  ctx.stroke();
  ctx.setLineDash([]);
}

// Event handlers
function randCode() {
  const len = Math.min(5, Math.max(1, ($('code').value || '').length || 4));
  const max = Math.pow(10, len);
  $('code').value = (Math.random() * max | 0).toString().padStart(len, '0');
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => { if(b.dataset.t==='code'){ randCode(); draw(); } };
});

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    el.value = DEF[k];
  }
  draw();
};

document.querySelectorAll('input, select').forEach(el => {
  if (!el.oninput) el.oninput = draw;
  if (!el.onchange) el.onchange = draw;
});

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};

// Initial
draw();
</script>
