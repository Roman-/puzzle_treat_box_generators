<!doctype html>
<meta charset="utf-8">
<title>Pattern Grid Deduction (2Ã—2 Tile) â€“ generator</title>

<!-- === size === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=400 min=100></label>

<!-- === 4-digit code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{1,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === creativity === -->
<label>Cell size (% of panel)
  <input id=cellSize type=range min=20 max=50 step=1 value=35>
</label><br>

<label>Difficulty
  <select id=difficulty>
    <option value="easy">Easy â€“ All cells same color</option>
    <option value="medium" selected>Medium â€“ Row/column pairs</option>
    <option value="hard">Hard â€“ Includes diagonals</option>
  </select>
</label><br>

<label>Display mode
  <select id=displayMode>
    <option value="both" selected>Color + Digit</option>
    <option value="color">Color only</option>
    <option value="digit">Digit only</option>
  </select>
</label><br>

<label>Panel spacing
  <input id=panelSpacing type=range min=10 max=80 step=2 value=40>
</label><br>

<label>Grid border
  <input id=gridBorder type=range min=1 max=6 step=0.5 value=3>
</label><br>

<label>Legend size (% of height)
  <input id=legendSize type=range min=3 max=10 step=0.5 value=5>
</label><br>

<button id=reset type=button>ðŸ”„ Restore defaults</button>
<button id=newPattern type=button>ðŸ”€ New patterns (same code)</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script src="../shared/colors.js"></script>
<script>
const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'pattern_grid_2x2';

const DEF = {
  w: 800, h: 400, code: '1234',
  cellSize: 35, difficulty: 'medium', displayMode: 'both',
  panelSpacing: 40, gridBorder: 3, legendSize: 5
};

// Store generated grids
let grids = [];

function generateGrid(answerDigit) {
  const difficulty = $('difficulty').value;

  // 2x2 grid: positions are [0,0], [0,1], [1,0], [1,1]
  // We'll generate based on difficulty
  let grid;
  let patternType;

  const pickOther = (exclude) => {
    let val;
    do { val = Math.floor(Math.random() * 10); } while (val === exclude);
    return val;
  };

  if (difficulty === 'easy') {
    // All same color
    grid = [
      [answerDigit, answerDigit],
      [answerDigit, answerDigit]
    ];
    patternType = 'allSame';
  } else if (difficulty === 'medium') {
    // Row pairs or column pairs
    const type = Math.random() < 0.5 ? 'rowPairs' : 'colPairs';
    const other = pickOther(answerDigit);

    if (type === 'rowPairs') {
      // Rows are same color
      const answerRow = Math.floor(Math.random() * 2);
      if (answerRow === 0) {
        grid = [
          [answerDigit, answerDigit],
          [other, other]
        ];
      } else {
        grid = [
          [other, other],
          [answerDigit, answerDigit]
        ];
      }
      patternType = 'rowPairs';
    } else {
      // Columns are same color
      const answerCol = Math.floor(Math.random() * 2);
      if (answerCol === 0) {
        grid = [
          [answerDigit, other],
          [answerDigit, other]
        ];
      } else {
        grid = [
          [other, answerDigit],
          [other, answerDigit]
        ];
      }
      patternType = 'colPairs';
    }
  } else {
    // Hard: includes diagonals
    const types = ['allSame', 'rowPairs', 'colPairs', 'diagonal'];
    const type = types[Math.floor(Math.random() * types.length)];
    const other = pickOther(answerDigit);

    if (type === 'allSame') {
      grid = [
        [answerDigit, answerDigit],
        [answerDigit, answerDigit]
      ];
      patternType = 'allSame';
    } else if (type === 'rowPairs') {
      const answerRow = Math.floor(Math.random() * 2);
      if (answerRow === 0) {
        grid = [
          [answerDigit, answerDigit],
          [other, other]
        ];
      } else {
        grid = [
          [other, other],
          [answerDigit, answerDigit]
        ];
      }
      patternType = 'rowPairs';
    } else if (type === 'colPairs') {
      const answerCol = Math.floor(Math.random() * 2);
      if (answerCol === 0) {
        grid = [
          [answerDigit, other],
          [answerDigit, other]
        ];
      } else {
        grid = [
          [other, answerDigit],
          [other, answerDigit]
        ];
      }
      patternType = 'colPairs';
    } else {
      // Diagonal: [0,0] = [1,1] and [0,1] = [1,0]
      // Two sub-types: answer on main diagonal or anti-diagonal
      const mainDiag = Math.random() < 0.5;
      if (mainDiag) {
        grid = [
          [answerDigit, other],
          [other, answerDigit]
        ];
      } else {
        grid = [
          [other, answerDigit],
          [answerDigit, other]
        ];
      }
      patternType = 'diagonal';
    }
  }

  // Pick a position for "?" that makes the pattern solvable
  // For any position, the answer should be deducible from the other 3 cells
  const positions = [[0,0], [0,1], [1,0], [1,1]];

  // For allSame: any position works
  // For rowPairs: pick position in row with answer
  // For colPairs: pick position in col with answer
  // For diagonal: pick any position

  let validPositions = positions.slice();

  if (patternType === 'rowPairs') {
    // Find the row containing answerDigit
    const answerRow = grid[0][0] === answerDigit ? 0 : 1;
    validPositions = positions.filter(p => p[0] === answerRow);
  } else if (patternType === 'colPairs') {
    const answerCol = grid[0][0] === answerDigit ? 0 : 1;
    validPositions = positions.filter(p => p[1] === answerCol);
  }

  const [qRow, qCol] = validPositions[Math.floor(Math.random() * validPositions.length)];

  return { grid, questionRow: qRow, questionCol: qCol, answerDigit, patternType };
}

function regenerateGrids() {
  const codeStr = $('code').value || '1234';
  const digits = codeStr.split('').map(Number);
  grids = digits.map(d => generateGrid(d));
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  if (grids.length === 0) regenerateGrids();

  const legendSizePct = +$('legendSize').value / 100;
  const legendCircleR = H * legendSizePct / 2;
  const legendY = legendCircleR * 1.5;

  // Draw legend
  const legendStartX = W * 0.05;
  const legendEndX = W * 0.95;
  const legendSpacing = (legendEndX - legendStartX) / 10;

  ctx.font = `bold ${legendCircleR * 1.2}px system-ui, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let i = 0; i < 10; i++) {
    const x = legendStartX + legendSpacing * i + legendSpacing / 2;

    ctx.beginPath();
    ctx.arc(x, legendY, legendCircleR, 0, Math.PI * 2);
    ctx.fillStyle = COLOR_HEX[i];
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.fillStyle = '#333';
    ctx.fillText(i.toString(), x, legendY + legendCircleR * 1.8);
  }

  // Separator line
  const separatorY = legendY + legendCircleR * 2.8;
  ctx.beginPath();
  ctx.moveTo(W * 0.02, separatorY);
  ctx.lineTo(W * 0.98, separatorY);
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Draw grids
  const numPanels = grids.length;
  const panelSpacing = +$('panelSpacing').value;
  const gridAreaTop = separatorY + 15;
  const gridAreaHeight = H - gridAreaTop - 15;
  const totalPanelWidth = W - 40;
  const panelWidth = (totalPanelWidth - (numPanels - 1) * panelSpacing) / numPanels;
  const cellSizePct = +$('cellSize').value / 100;

  const maxCellW = panelWidth * cellSizePct;
  const maxCellH = gridAreaHeight * cellSizePct;
  const cellSize = Math.min(maxCellW, maxCellH);

  const borderWidth = +$('gridBorder').value;
  const displayMode = $('displayMode').value;

  for (let p = 0; p < numPanels; p++) {
    const { grid, questionRow, questionCol, answerDigit, patternType } = grids[p];
    const gridWidth = cellSize * 2;
    const gridHeight = cellSize * 2;

    const panelX = 20 + p * (panelWidth + panelSpacing);
    const panelCenterX = panelX + panelWidth / 2;
    const gridLeft = panelCenterX - gridWidth / 2;
    const gridTop = gridAreaTop + (gridAreaHeight - gridHeight) / 2;

    // Draw grid cells
    for (let row = 0; row < 2; row++) {
      for (let col = 0; col < 2; col++) {
        const x = gridLeft + col * cellSize;
        const y = gridTop + row * cellSize;
        const value = grid[row][col];
        const isQuestion = row === questionRow && col === questionCol;

        // Cell background
        if (isQuestion) {
          ctx.fillStyle = '#fff';
        } else if (displayMode !== 'digit') {
          ctx.fillStyle = COLOR_HEX[value];
        } else {
          ctx.fillStyle = '#f5f5f5';
        }
        ctx.fillRect(x, y, cellSize, cellSize);

        // Cell border
        ctx.strokeStyle = '#333';
        ctx.lineWidth = borderWidth;
        ctx.strokeRect(x, y, cellSize, cellSize);

        // Cell content
        const centerX = x + cellSize / 2;
        const centerY = y + cellSize / 2;
        const fontSize = cellSize * 0.45;
        ctx.font = `bold ${fontSize}px system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (isQuestion) {
          ctx.fillStyle = '#666';
          ctx.fillText('?', centerX, centerY);
        } else if (displayMode === 'both') {
          ctx.fillStyle = '#fff';
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 1;
          ctx.strokeText(value.toString(), centerX, centerY);
          ctx.fillText(value.toString(), centerX, centerY);
        } else if (displayMode === 'digit') {
          ctx.fillStyle = '#333';
          ctx.fillText(value.toString(), centerX, centerY);
        }
      }
    }
  }
}

// Event handlers
function randCode() {
  const len = Math.min(5, Math.max(1, ($('code').value || '').length || 4));
  const max = Math.pow(10, len);
  $('code').value = (Math.random() * max | 0).toString().padStart(len, '0');
  regenerateGrids();
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => { if (b.dataset.t === 'code') { randCode(); draw(); } };
});

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (!el) continue;
    if (el.type === 'checkbox') el.checked = DEF[k];
    else el.value = DEF[k];
  }
  regenerateGrids();
  draw();
};

$('newPattern').onclick = () => {
  regenerateGrids();
  draw();
};

$('code').oninput = () => { regenerateGrids(); draw(); };
$('difficulty').onchange = () => { regenerateGrids(); draw(); };

document.querySelectorAll('input, select').forEach(el => {
  if (!el.oninput) el.oninput = draw;
  if (!el.onchange) el.onchange = draw;
});

// Download
$('can').onclick = () => {
  const c = $('code').value || '0000';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  draw();
};

// Initial
regenerateGrids();
draw();
</script>
