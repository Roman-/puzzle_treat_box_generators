<!doctype html>
<meta charset="utf-8">
<title>Gradient Color Decoder v3 â€“ Plateau Gradient</title>

<!-- === size first === -->
<label>W <input id=w type=number value=800 min=100></label>
<label>H <input id=h type=number value=400 min=100></label>

<!-- === 4-digit code + ðŸŽ² === -->
<label>Code <input id=code type=text value=1234 pattern="\d{3,5}" maxlength=5></label>
<button type=button data-t="code">ðŸŽ²</button>

<hr>

<!-- === creativity === -->
<label>Extra legend colors (0-3)
  <input id=extraColors type=number min=0 max=3 value=1>
</label><br>

<label>Strip height (Ã— H)
  <input id=stripHeight type=range min=0.15 max=0.40 step=0.01 value=0.25>
</label><br>

<label>Solid zone width (Ã— section)
  <input id=plateauWidth type=range min=0.3 max=0.8 step=0.05 value=0.5>
</label><br>

<label>Legend circle size (Ã— H)
  <input id=legendSize type=range min=0.05 max=0.15 step=0.01 value=0.08>
</label><br>

<label>Marker height (Ã— strip height)
  <input id=markerHeight type=range min=0.2 max=0.5 step=0.05 value=0.3>
</label><br>

<label>Question mark size (Ã— strip height)
  <input id=qmarkSize type=range min=0.2 max=0.6 step=0.05 value=0.4>
</label><br>

<button id=reset type=button>Restore defaults</button>
<button id=rerender type=button>Re-render</button>

<hr>

<canvas id=can title="Click to download" style="border:1px solid grey;cursor:pointer"></canvas>

<script>
// Display current value next to range inputs
document.querySelectorAll('input[type=range]').forEach(r => {
  const span = document.createElement('span');
  span.style.cssText = 'margin-left:4px;font-size:12px;color:#666';
  span.textContent = r.value;
  r.after(span);
  r.addEventListener('input', () => span.textContent = r.value);
});
</script>

<script>
const $ = id => document.getElementById(id);
const ctx = $('can').getContext('2d');
const NAME = 'gradient_plateau';

const DEF = {
  w: 800, h: 400, code: '1234',
  extraColors: 1, stripHeight: 0.25, plateauWidth: 0.5,
  legendSize: 0.08, markerHeight: 0.3, qmarkSize: 0.4
};

// HSV to RGB conversion
function hsvToRgb(h, s, v) {
  h = h / 360;
  let r, g, b;
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0: r = v; g = t; b = p; break;
    case 1: r = q; g = v; b = p; break;
    case 2: r = p; g = v; b = t; break;
    case 3: r = p; g = q; b = v; break;
    case 4: r = t; g = p; b = v; break;
    case 5: r = v; g = p; b = q; break;
  }
  return `rgb(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)})`;
}

// Generate K distinct colors with at least 30Â° hue separation
function generateColors(k) {
  const saturation = 0.8 + Math.random() * 0.2;
  const value = 0.8 + Math.random() * 0.2;
  const colors = [];
  const usedHues = [];

  for (let i = 0; i < k; i++) {
    let hue;
    let attempts = 0;
    do {
      hue = Math.random() * 360;
      attempts++;
    } while (attempts < 100 && usedHues.some(h => Math.min(Math.abs(h - hue), 360 - Math.abs(h - hue)) < 30));

    usedHues.push(hue);
    colors.push({ hue, color: hsvToRgb(hue, saturation, value) });
  }
  return colors;
}

// Generate random edge colors
function generateRandomColor() {
  const hue = Math.random() * 360;
  const sat = 0.5 + Math.random() * 0.5;
  const val = 0.6 + Math.random() * 0.4;
  return hsvToRgb(hue, sat, val);
}

// State
let colorMap = {};
let legendDigits = [];
let leftEdgeColor = '';
let rightEdgeColor = '';

function regenerate() {
  const codeStr = $('code').value || '1234';
  const digits = codeStr.split('').map(Number);
  const uniqueDigits = [...new Set(digits)].sort((a, b) => a - b);

  const extraCount = Math.min(+$('extraColors').value, 10 - uniqueDigits.length);

  const allDigits = [...uniqueDigits];
  const available = [0,1,2,3,4,5,6,7,8,9].filter(d => !uniqueDigits.includes(d));
  for (let i = 0; i < extraCount && available.length > 0; i++) {
    const idx = Math.floor(Math.random() * available.length);
    allDigits.push(available.splice(idx, 1)[0]);
  }
  allDigits.sort((a, b) => a - b);
  legendDigits = allDigits;

  const colors = generateColors(legendDigits.length);
  colorMap = {};
  legendDigits.forEach((digit, i) => {
    colorMap[digit] = colors[i].color;
  });

  leftEdgeColor = generateRandomColor();
  rightEdgeColor = generateRandomColor();
}

function draw() {
  const W = +$('w').value, H = +$('h').value;
  $('can').width = W; $('can').height = H;
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, W, H);

  const codeStr = $('code').value || '1234';
  const digits = codeStr.split('').map(Number);
  const N = digits.length;

  const legendCircleR = +$('legendSize').value * H / 2;
  const stripH = +$('stripHeight').value * H;
  const plateauFrac = +$('plateauWidth').value;
  const markerFrac = +$('markerHeight').value;
  const qmarkFrac = +$('qmarkSize').value;

  const margin = W * 0.05;
  const legendY = legendCircleR * 1.5;
  const stripY = H * 0.50;
  const stripWidth = W - 2 * margin;

  // Draw legend
  const legendSpacing = (W - 2 * margin) / legendDigits.length;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  legendDigits.forEach((digit, i) => {
    const x = margin + legendSpacing * (i + 0.5);

    ctx.beginPath();
    ctx.arc(x, legendY, legendCircleR, 0, Math.PI * 2);
    ctx.fillStyle = colorMap[digit];
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.stroke();

    ctx.fillStyle = '#000';
    ctx.font = `bold ${legendCircleR * 1.2}px sans-serif`;
    ctx.fillText(digit.toString(), x, legendY + legendCircleR * 1.8);
  });

  // Separator
  const sepY = legendY + legendCircleR * 2.8;
  ctx.beginPath();
  ctx.moveTo(margin, sepY);
  ctx.lineTo(W - margin, sepY);
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Build plateau gradient
  // Structure: [edge] -> [trans] -> [plateau1] -> [trans] -> [plateau2] -> ... -> [trans] -> [edge]
  const edgeWidth = 0.05; // 5% on each edge
  const sectionWidth = (1 - 2 * edgeWidth) / N;
  const plateauWidthActual = sectionWidth * plateauFrac;
  const transWidth = (sectionWidth - plateauWidthActual) / 2;

  const grad = ctx.createLinearGradient(margin, 0, margin + stripWidth, 0);

  // Left edge
  grad.addColorStop(0, leftEdgeColor);
  grad.addColorStop(edgeWidth, leftEdgeColor);

  // Build stops for each digit
  for (let i = 0; i < N; i++) {
    const color = colorMap[digits[i]];
    const sectionStart = edgeWidth + i * sectionWidth;
    const plateauStart = sectionStart + transWidth;
    const plateauEnd = plateauStart + plateauWidthActual;

    // Transition INTO this plateau
    if (i === 0) {
      // From edge color
      grad.addColorStop(plateauStart - 0.001, leftEdgeColor);
    }
    // Plateau (solid color zone)
    grad.addColorStop(plateauStart, color);
    grad.addColorStop(plateauEnd, color);

    // Transition to next or to edge
    if (i < N - 1) {
      const nextColor = colorMap[digits[i + 1]];
      const nextPlateauStart = edgeWidth + (i + 1) * sectionWidth + transWidth;
      // Gradient transition zone ends where next plateau begins
      grad.addColorStop(nextPlateauStart - 0.001, nextColor);
    }
  }

  // Right edge
  const lastPlateauEnd = edgeWidth + (N - 1) * sectionWidth + transWidth + plateauWidthActual;
  grad.addColorStop(lastPlateauEnd + 0.001, rightEdgeColor);
  grad.addColorStop(1 - edgeWidth, rightEdgeColor);
  grad.addColorStop(1, rightEdgeColor);

  ctx.fillStyle = grad;
  ctx.fillRect(margin, stripY, stripWidth, stripH);

  // Strip outline
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  ctx.strokeRect(margin, stripY, stripWidth, stripH);

  // Draw markers (triangles pointing up) and question marks
  const markerPx = stripH * markerFrac;
  const qmarkY = stripY + stripH + markerPx + 5;

  ctx.fillStyle = '#666';
  ctx.font = `bold ${stripH * qmarkFrac}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';

  for (let i = 0; i < N; i++) {
    // Center of plateau for this digit
    const sectionStart = edgeWidth + i * sectionWidth;
    const plateauCenter = sectionStart + transWidth + plateauWidthActual / 2;
    const x = margin + plateauCenter * stripWidth;

    // Draw triangle marker
    ctx.beginPath();
    ctx.moveTo(x, stripY + stripH + 2);
    ctx.lineTo(x - markerPx * 0.4, stripY + stripH + markerPx);
    ctx.lineTo(x + markerPx * 0.4, stripY + stripH + markerPx);
    ctx.closePath();
    ctx.fillStyle = '#555';
    ctx.fill();

    // Question mark
    ctx.fillStyle = '#666';
    ctx.fillText('?', x, qmarkY);
  }
}

// Event handlers
function randCode() {
  const numDigits = ($('code').value || '1234').length;
  const max = Math.pow(10, numDigits);
  $('code').value = (Math.random() * max | 0).toString().padStart(numDigits, '0');
}

document.querySelectorAll('[data-t]').forEach(b => {
  b.onclick = () => {
    if (b.dataset.t === 'code') {
      randCode();
      regenerate();
      draw();
    }
  };
});

$('code').oninput = () => { regenerate(); draw(); };
$('extraColors').oninput = () => { regenerate(); draw(); };

document.querySelectorAll('input[type=range]').forEach(el => {
  el.oninput = draw;
});

$('reset').onclick = () => {
  for (const k in DEF) {
    const el = $(k);
    if (el) el.value = DEF[k];
  }
  document.querySelectorAll('input[type=range]').forEach(r => {
    const span = r.nextElementSibling;
    if (span) span.textContent = r.value;
  });
  regenerate();
  draw();
};

$('rerender').onclick = () => {
  regenerate();
  draw();
};

$('can').onclick = () => {
  const c = $('code').value || '1234';
  const a = document.createElement('a');
  a.download = `${NAME}_${c}.png`;
  a.href = $('can').toDataURL();
  a.click();
  randCode();
  regenerate();
  draw();
};

regenerate();
draw();
</script>
