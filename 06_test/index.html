<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>5‚ÄëDigit Color Puzzle Generator</title>
  <style>
    :root { color-scheme: light; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#f6f7fb; color:#111; }
    header { padding: 14px 16px 8px; background: #fff; border-bottom: 1px solid #e6e7ee; }
    .wrap { max-width: 1200px; margin: 0 auto; }
    main .wrap { max-width: 100%; }
    .row { display:flex; flex-wrap: wrap; gap: 10px 14px; align-items: end; }
    .control {
      display:flex; flex-direction:column; gap: 6px;
      padding: 10px 12px; background:#fff; border:1px solid #e6e7ee; border-radius: 12px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
    }
    .control label { font-size: 12px; color:#333; }
    .control input[type="range"] { width: 220px; }
    .control input[type="number"], .control input[type="text"], .control select {
      padding: 8px 10px; border-radius: 10px; border:1px solid #d7d9e4; font-size: 14px; background:#fff;
    }
    .control .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btnbar { display:flex; gap: 8px; flex-wrap: wrap; }
    button {
      padding: 9px 12px; border-radius: 10px; border: 1px solid #d7d9e4; background: #fff;
      cursor:pointer; font-weight: 600;
    }
    button.primary { background:#111; color:#fff; border-color:#111; }
    button:active { transform: translateY(1px); }
    .hint { font-size: 12px; color:#555; margin-top: 6px; line-height: 1.35; }
    .ref {
      margin-top: 10px; padding: 12px; background:#fff; border:1px solid #e6e7ee; border-radius: 12px;
    }
    .ref h3 { margin: 0 0 8px; font-size: 14px; }
    .swatches { display:flex; flex-wrap: wrap; gap: 8px; }
    .swatch {
      display:flex; align-items:center; gap: 10px;
      padding: 8px 10px; border:1px solid #e6e7ee; border-radius: 10px; background:#fafbff;
    }
    .chip {
      width: 36px; height: 22px; border-radius: 6px; border:1px solid rgba(0,0,0,0.25);
      display:flex; align-items:center; justify-content:center; font-weight:800; letter-spacing:0.5px;
      user-select:none;
    }
    main { padding: 14px 16px 22px; }
    .canvasWrap {
      background:#fff; border:1px solid #e6e7ee; border-radius: 14px; padding: 10px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
      overflow:auto;
    }
    canvas { display:block; border-radius: 10px; background: #ffffff; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; padding: 2px 6px; border: 1px solid #d7d9e4; border-radius: 6px; background:#fff; }
    .tiny { font-size:12px; color:#444; }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div class="control">
        <label>Canvas size (px)</label>
        <div class="inline">
          <label class="tiny">W</label><input id="w" type="number" value="1800" min="400" max="4000" step="50" style="width:110px" />
          <label class="tiny">H</label><input id="h" type="number" value="520" min="300" max="2000" step="10" style="width:110px" />
        </div>
        <div class="hint">Downloaded PNG uses these dimensions.</div>
      </div>

      <div class="control">
        <label for="pattern">Pattern type</label>
        <select id="pattern">
          <option value="mixed">Mixed (random per digit)</option>
          <option value="progression">Progression Grid</option>
          <option value="sum">Row+Column Sum</option>
          <option value="mirror">Mirror Symmetry</option>
          <option value="radial">Radial Wedges</option>
        </select>
        <div class="hint">Each panel has exactly one missing region (with ‚Äú?‚Äù). Solve left‚Üíright to get a 5‚Äëdigit code.</div>
      </div>

      <div class="control">
        <label for="difficulty">Difficulty (rule complexity)</label>
        <input id="difficulty" type="range" min="1" max="5" value="3" />
        <div class="tiny">Value: <span id="difficultyVal">3</span></div>
      </div>

      <div class="control">
        <label for="granularity">Granularity (how many pieces)</label>
        <input id="granularity" type="range" min="1" max="5" value="3" />
        <div class="tiny">Value: <span id="granularityVal">3</span></div>
      </div>

      <div class="control">
        <label>Seed (reproducible)</label>
        <div class="inline">
          <input id="seed" type="text" value="" placeholder="e.g. 12345 or hello" style="width:220px" />
          <button id="randSeed" title="Randomize seed">üé≤</button>
        </div>
        <div class="hint">Same seed + settings ‚áí same puzzle.</div>
      </div>

      <div class="control">
        <label>View (pan/zoom)</label>
        <div class="inline">
          <label class="tiny">Scale</label>
          <input id="scale" type="range" min="50" max="200" value="100" />
          <span class="tiny"><span id="scaleVal">100</span>%</span>
        </div>
        <div class="inline">
          <label class="tiny">X</label><input id="offX" type="number" value="0" step="10" style="width:96px" />
          <label class="tiny">Y</label><input id="offY" type="number" value="0" step="10" style="width:96px" />
          <button id="resetView" title="Reset view">Reset</button>
        </div>
        <div class="hint">Drag canvas to pan. Mouse‚Äëwheel to zoom.</div>
      </div>

      <div class="control">
        <label>Actions</label>
        <div class="btnbar">
          <button class="primary" id="newPuzzle">New puzzle</button>
          <button id="download">Download PNG</button>
          <button id="print">Print</button>
        </div>
        <div class="inline">
          <label class="tiny"><input id="refOnCanvas" type="checkbox" checked /> Include reference in canvas</label>
        </div>
      </div>
    </div>

    <div class="ref">
      <h3>Reference table (digit ‚Üí color)</h3>
      <div id="swatches" class="swatches"></div>
      <div class="hint">Tip: For ‚ÄúRow+Column Sum‚Äù, the headers are digits too (via the same table) and each interior cell is <span class="kbd">row + column (mod 10)</span>.</div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="canvasWrap">
      <canvas id="c"></canvas>
    </div>
  </div>
</main>

<script>
(() => {
  "use strict";

  // ---------- Small utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const mod = (n, m) => ((n % m) + m) % m;

  // Hash a string to a uint32 seed (deterministic).
  function hash32(str) {
    // FNV-1a-ish
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }

  function mulberry32(seed) {
    let t = seed >>> 0;
    return function() {
      t += 0x6D2B79F5;
      let x = Math.imul(t ^ (t >>> 15), 1 | t);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }

  function makeRng(seedStr) {
    const s = hash32(seedStr || String(Date.now()));
    const r = mulberry32(s);
    return {
      seed: s,
      float: () => r(),
      int: (n) => Math.floor(r() * n),
      rangeInt: (a, bInclusive) => a + Math.floor(r() * (bInclusive - a + 1)),
      pick: (arr) => arr[Math.floor(r() * arr.length)],
      shuffle: (arr) => {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(r() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }
    };
  }

  // ---------- Color palette generation (greedy in Lab space) ----------
  function hslToRgb(h, s, l) {
    const c = (1 - Math.abs(2*l - 1)) * s;
    const hp = (h % 360) / 60;
    const x = c * (1 - Math.abs((hp % 2) - 1));
    let [r1, g1, b1] = [0, 0, 0];
    if (0 <= hp && hp < 1) [r1, g1, b1] = [c, x, 0];
    else if (1 <= hp && hp < 2) [r1, g1, b1] = [x, c, 0];
    else if (2 <= hp && hp < 3) [r1, g1, b1] = [0, c, x];
    else if (3 <= hp && hp < 4) [r1, g1, b1] = [0, x, c];
    else if (4 <= hp && hp < 5) [r1, g1, b1] = [x, 0, c];
    else if (5 <= hp && hp < 6) [r1, g1, b1] = [c, 0, x];

    const m = l - c/2;
    const r = r1 + m, g = g1 + m, b = b1 + m;
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  }

  function srgbToLinear(u) {
    const v = u / 255;
    return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  }

  function rgbToXyz(r, g, b) {
    // sRGB D65
    const R = srgbToLinear(r), G = srgbToLinear(g), B = srgbToLinear(b);
    const X = R * 0.4124564 + G * 0.3575761 + B * 0.1804375;
    const Y = R * 0.2126729 + G * 0.7151522 + B * 0.0721750;
    const Z = R * 0.0193339 + G * 0.1191920 + B * 0.9503041;
    return [X, Y, Z];
  }

  function xyzToLab(X, Y, Z) {
    // D65 reference white
    const Xn = 0.95047, Yn = 1.0, Zn = 1.08883;
    let x = X / Xn, y = Y / Yn, z = Z / Zn;

    const f = (t) => t > 0.008856 ? Math.cbrt(t) : (7.787 * t + 16/116);
    const fx = f(x), fy = f(y), fz = f(z);
    const L = 116 * fy - 16;
    const a = 500 * (fx - fy);
    const b = 200 * (fy - fz);
    return [L, a, b];
  }

  function rgbToLab(r, g, b) {
    const [X, Y, Z] = rgbToXyz(r, g, b);
    return xyzToLab(X, Y, Z);
  }

  function deltaE76(lab1, lab2) {
    const dL = lab1[0] - lab2[0];
    const da = lab1[1] - lab2[1];
    const db = lab1[2] - lab2[2];
    return Math.sqrt(dL*dL + da*da + db*db);
  }

  function rgbToHex(r, g, b) {
    const to2 = (n) => n.toString(16).padStart(2, "0");
    return "#" + to2(r) + to2(g) + to2(b);
  }

  function luminance(r, g, b) {
    // relative luminance per WCAG
    const sr = r/255, sg = g/255, sb = b/255;
    const lin = (u) => (u <= 0.03928) ? u/12.92 : Math.pow((u+0.055)/1.055, 2.4);
    return 0.2126*lin(sr) + 0.7152*lin(sg) + 0.0722*lin(sb);
  }

  function generateDistinctPalette10() {
    // Greedy max-min in Lab from an HSL candidate pool.
    const candidates = [];
    const S = [0.92, 0.82];      // high saturation
    const L = [0.38, 0.50, 0.60]; // avoid very dark/light for printing
    for (let h = 0; h < 360; h += 2) {
      for (const s of S) for (const l of L) {
        const [r, g, b] = hslToRgb(h, s, l);
        // exclude near-white and near-black; keep mid luminance
        const lum = luminance(r, g, b);
        if (lum < 0.12 || lum > 0.88) continue;
        const lab = rgbToLab(r, g, b);
        candidates.push({ h, s, l, r, g, b, hex: rgbToHex(r,g,b), lab });
      }
    }

    // Start from a strong blue-ish hue as a stable anchor.
    let selected = [];
    let start = candidates.reduce((best, c) => {
      const score = Math.abs(c.h - 210) < 2 ? 9999 : 0; // prefer ~210¬∞
      return score > (best.score || 0) ? { ...c, score } : best;
    }, {});
    selected.push(start);

    while (selected.length < 10) {
      let best = null;
      let bestMin = -1;
      for (const c of candidates) {
        // Skip if already selected (hex match)
        if (selected.some(s => s.hex === c.hex)) continue;
        let minD = Infinity;
        for (const s of selected) {
          const d = deltaE76(c.lab, s.lab);
          if (d < minD) minD = d;
          if (minD < bestMin) break;
        }
        if (minD > bestMin) {
          bestMin = minD;
          best = c;
        }
      }
      if (!best) break;
      selected.push(best);
    }

    // If we somehow underfill, fall back by padding with remaining candidates.
    if (selected.length < 10) {
      for (const c of candidates) {
        if (selected.length >= 10) break;
        if (!selected.some(s => s.hex === c.hex)) selected.push(c);
      }
    }

    // Return only hex, plus recommended text color.
    const base = selected.slice(0,10).map(c => {
      const txt = luminance(c.r,c.g,c.b) > 0.5 ? "#111" : "#fff";
      return { hex: c.hex, text: txt, rgb: [c.r,c.g,c.b] };
    });

    // Manual tweaks for clearer separation of similar pairs.
    const parseHex = (hex) => {
      const v = hex.replace("#","").padStart(6,"0");
      const r = parseInt(v.slice(0,2),16);
      const g = parseInt(v.slice(2,4),16);
      const b = parseInt(v.slice(4,6),16);
      const txt = luminance(r,g,b) > 0.5 ? "#111" : "#fff";
      return { hex: `#${v.toUpperCase()}`, text: txt, rgb: [r,g,b] };
    };
    const overrides = {
      0: "#1f64e0", // vivid blue
      7: "#f28c28", // bright orange
      4: "#24c08b", // teal-green
      6: "#7a3cff", // purple
    };
    for (const [idxStr, hex] of Object.entries(overrides)) {
      const idx = Number(idxStr);
      base[idx] = parseHex(hex);
    }
    return base;
  }

  // ---------- Puzzle patterns ----------
  const PATTERNS = ["progression", "sum", "mirror", "radial"];

  function stepsForDifficulty(d) {
    // Keep steps non-zero and varied.
    const max = [1, 3, 5, 9, 9][d-1];
    const min = 1;
    return { min, max };
  }

  function genProgressionPanel(rng, difficulty, granularity) {
    const N = 2 + granularity; // 3..7
    const { min, max } = stepsForDifficulty(difficulty);
    const rowStep = rng.rangeInt(min, max);
    let colStep = rng.rangeInt(min, max);
    if (difficulty >= 3 && colStep === rowStep) colStep = mod(colStep + 1, 10) || 1;
    const base = rng.int(10);

    const missingR = rng.int(N);
    const missingC = rng.int(N);

    const values = Array.from({length:N}, (_, r) =>
      Array.from({length:N}, (_, c) => mod(base + r*rowStep + c*colStep, 10))
    );
    const answerDigit = values[missingR][missingC];

    return {
      kind: "progression",
      N, base, rowStep, colStep,
      missingR, missingC,
      values,
      answerDigit,
      hintIcon: "‚ÜòÔ∏é" // gentle hint that it‚Äôs a structured grid
    };
  }

  function genSumPanel(rng, difficulty, granularity) {
    const N = 2 + granularity; // 3..7
    const row = Array.from({length:N}, () => rng.int(10));
    const col = Array.from({length:N}, () => rng.int(10));

    const values = Array.from({length:N}, (_, r) =>
      Array.from({length:N}, (_, c) => mod(row[r] + col[c], 10))
    );

    const missingR = rng.int(N);
    const missingC = rng.int(N);
    const answerDigit = values[missingR][missingC];

    // Slight complexity bump: optionally permute headers at higher difficulty
    // (still solvable because headers are visible, just less ‚Äúordered-looking‚Äù).
    if (difficulty >= 4) {
      rng.shuffle(row);
      rng.shuffle(col);
      for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) values[r][c] = mod(row[r] + col[c], 10);
    }

    return {
      kind: "sum",
      N, row, col, values,
      missingR, missingC,
      answerDigit,
      hintIcon: "+"
    };
  }

  function genMirrorPanel(rng, difficulty, granularity) {
    const N = 3 + granularity; // 4..8
    const H = N, W = N;
    const values = Array.from({length:H}, () => Array.from({length:W}, () => 0));

    // Create left half random then mirror right half.
    const half = Math.ceil(W/2);
    for (let r = 0; r < H; r++) {
      for (let c = 0; c < half; c++) values[r][c] = rng.int(10);
    }

    // Symmetry: vertical always; optionally add horizontal symmetry at difficulty 5.
    for (let r = 0; r < H; r++) {
      for (let c = 0; c < W; c++) {
        const mirroredC = W - 1 - c;
        if (c >= half) values[r][c] = values[r][mirroredC];
      }
    }
    if (difficulty >= 5) {
      for (let r = 0; r < H; r++) {
        const rr = H - 1 - r;
        for (let c = 0; c < W; c++) values[rr][c] = values[r][c];
      }
    }

    // Pick missing cell not on the symmetry axis if possible.
    let missingR = rng.int(H), missingC = rng.int(W);
    const axisC = (W - 1) / 2;
    let tries = 0;
    while (tries++ < 50 && Math.abs(missingC - axisC) < 0.01) {
      missingR = rng.int(H); missingC = rng.int(W);
    }
    const answerDigit = values[missingR][missingC];

    return {
      kind: "mirror",
      H, W,
      values,
      missingR, missingC,
      answerDigit,
      hintIcon: "‚éØ‚éØ|‚éØ‚éØ"
    };
  }

  function genRadialPanel(rng, difficulty, granularity) {
    const segments = 6 + 2*granularity; // 8..16
    const start = rng.int(10);
    const { min, max } = stepsForDifficulty(difficulty);

    // At highest difficulty, alternate steps a,b (still solvable).
    let stepA = rng.rangeInt(min, max);
    let stepB = rng.rangeInt(min, max);
    if (difficulty < 5) stepB = stepA;

    const seq = [];
    let v = start;
    for (let i = 0; i < segments; i++) {
      seq.push(v);
      const step = (i % 2 === 0) ? stepA : stepB;
      v = mod(v + step, 10);
    }

    const missingI = rng.int(segments);
    const answerDigit = seq[missingI];

    return {
      kind: "radial",
      segments,
      start,
      stepA,
      stepB,
      seq,
      missingI,
      answerDigit,
      hintIcon: (difficulty >= 5 ? "‚ü≥ AB" : "‚ü≥")
    };
  }

  function generatePanel(type, rng, difficulty, granularity) {
    switch (type) {
      case "progression": return genProgressionPanel(rng, difficulty, granularity);
      case "sum":         return genSumPanel(rng, difficulty, granularity);
      case "mirror":      return genMirrorPanel(rng, difficulty, granularity);
      case "radial":      return genRadialPanel(rng, difficulty, granularity);
      default:            return genProgressionPanel(rng, difficulty, granularity);
    }
  }

  // ---------- Drawing ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function setCanvasSize() {
    const dpr = window.devicePixelRatio || 1;
    const w = clamp(Number(ui.w.value) || 0, 200, 4000);
    const h = clamp(Number(ui.h.value) || 0, 200, 2000);
    ui.w.value = String(w);
    ui.h.value = String(h);
    canvas.width  = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;
    return { w, h, dpr };
  }

  function drawRoundedRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawCenterText(ctx, text, x, y, maxW, fontPx, color="#111") {
    ctx.fillStyle = color;
    ctx.font = `800 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    // shrink-to-fit
    let size = fontPx;
    ctx.font = `800 ${size}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
    while (ctx.measureText(text).width > maxW && size > 8) {
      size -= 1;
      ctx.font = `800 ${size}px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
    }
    ctx.fillText(text, x, y);
  }

  function drawQuestionMark(ctx, x, y, w, h) {
    ctx.save();
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "rgba(0,0,0,0.45)";
    ctx.lineWidth = 2;
    drawRoundedRect(ctx, x, y, w, h, Math.min(w,h)*0.12);
    ctx.fill();
    ctx.stroke();
    drawCenterText(ctx, "?", x+w/2, y+h/2, w*0.7, Math.min(w,h)*0.65, "#111");
    ctx.restore();
  }

  function fillCell(ctx, x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);
  }

  function drawPanelFrame(ctx, rect, title, hintIcon, opts = {}) {
    const { hideHeader = false } = opts;
    ctx.save();
    ctx.fillStyle = "#fbfcff";
    ctx.strokeStyle = "rgba(0,0,0,0.18)";
    ctx.lineWidth = 2;
    drawRoundedRect(ctx, rect.x, rect.y, rect.w, rect.h, 16);
    ctx.fill();
    ctx.stroke();

    if (!hideHeader) {
      // Title bar
      const pad = 14;
      ctx.fillStyle = "rgba(0,0,0,0.06)";
      drawRoundedRect(ctx, rect.x+pad, rect.y+pad, rect.w-2*pad, 34, 12);
      ctx.fill();

      ctx.fillStyle = "#111";
      ctx.font = `800 14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(title, rect.x+pad+12, rect.y+pad+17);

      ctx.textAlign = "right";
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.font = `800 12px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
      ctx.fillText(hintIcon || "", rect.x+rect.w-pad-10, rect.y+pad+17);
    }

    ctx.restore();
  }

  function drawProgression(ctx, rect, panel, palette) {
    drawPanelFrame(ctx, rect, "Progression grid", panel.hintIcon);
    const pad = 18;
    const top = rect.y + 58;
    const areaH = rect.h - 70;
    const areaW = rect.w - 2*pad;
    const N = panel.N;
    const cell = Math.min(areaW / N, areaH / N);
    const gridW = cell * N;
    const gridH = cell * N;
    const x0 = rect.x + (rect.w - gridW)/2;
    const y0 = top + (areaH - gridH)/2;

    // background grid
    for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) {
      const x = x0 + c*cell, y = y0 + r*cell;
      if (r === panel.missingR && c === panel.missingC) continue;
      const d = panel.values[r][c];
      fillCell(ctx, x, y, cell, cell, palette[d].hex);
    }

    // missing
    drawQuestionMark(ctx, x0 + panel.missingC*cell, y0 + panel.missingR*cell, cell, cell);
  }

  function drawSum(ctx, rect, panel, palette) {
    drawPanelFrame(ctx, rect, "Row + column (mod 10)", panel.hintIcon);
    const pad = 18;
    const top = rect.y + 58;
    const areaH = rect.h - 70;
    const areaW = rect.w - 2*pad;

    const N = panel.N;
    const total = N + 1; // header + N cells
    const cell = Math.min(areaW / total, areaH / total);
    const gridW = cell * total;
    const gridH = cell * total;
    const x0 = rect.x + (rect.w - gridW)/2;
    const y0 = top + (areaH - gridH)/2;

    // Corner: plus sign
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.06)";
    ctx.fillRect(x0, y0, cell, cell);
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.strokeRect(x0, y0, cell, cell);
    drawCenterText(ctx, "+", x0+cell/2, y0+cell/2, cell*0.8, cell*0.6, "rgba(0,0,0,0.7)");
    ctx.restore();

    // Column headers
    for (let c = 0; c < N; c++) {
      fillCell(ctx, x0 + (c+1)*cell, y0, cell, cell, palette[panel.col[c]].hex);
    }
    // Row headers
    for (let r = 0; r < N; r++) {
      fillCell(ctx, x0, y0 + (r+1)*cell, cell, cell, palette[panel.row[r]].hex);
    }

    // Cells
    for (let r = 0; r < N; r++) for (let c = 0; c < N; c++) {
      const x = x0 + (c+1)*cell;
      const y = y0 + (r+1)*cell;
      if (r === panel.missingR && c === panel.missingC) continue;
      fillCell(ctx, x, y, cell, cell, palette[panel.values[r][c]].hex);
    }
    drawQuestionMark(ctx, x0 + (panel.missingC+1)*cell, y0 + (panel.missingR+1)*cell, cell, cell);
  }

  function drawMirror(ctx, rect, panel, palette) {
    drawPanelFrame(ctx, rect, "", "", { hideHeader: true });
    const pad = 18;
    const top = rect.y + 18;
    const areaH = rect.h - 40;
    const areaW = rect.w - 2*pad;

    const H = panel.H, W = panel.W;
    const cell = Math.min(areaW / W, areaH / H);
    const gridW = cell * W;
    const gridH = cell * H;
    const x0 = rect.x + (rect.w - gridW)/2;
    const y0 = top + (areaH - gridH)/2;

    for (let r = 0; r < H; r++) for (let c = 0; c < W; c++) {
      const x = x0 + c*cell;
      const y = y0 + r*cell;
      if (r === panel.missingR && c === panel.missingC) continue;
      fillCell(ctx, x, y, cell, cell, palette[panel.values[r][c]].hex);
    }
    drawQuestionMark(ctx, x0 + panel.missingC*cell, y0 + panel.missingR*cell, cell, cell);

    // Mirror line
    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.55)";
    ctx.lineWidth = 2;
    const midX = x0 + gridW/2;
    ctx.beginPath();
    ctx.moveTo(midX, y0 - 6);
    ctx.lineTo(midX, y0 + gridH + 6);
    ctx.stroke();
    ctx.restore();
  }

  function drawRadial(ctx, rect, panel, palette) {
    drawPanelFrame(ctx, rect, "Radial wedges", panel.hintIcon);
    const cx = rect.x + rect.w/2;
    const cy = rect.y + rect.h/2 + 14;
    const R = Math.min(rect.w, rect.h) * 0.34;
    const seg = panel.segments;
    const angle0 = -Math.PI/2; // start at top

    // Outer ring wedges
    for (let i = 0; i < seg; i++) {
      const a1 = angle0 + (i/seg) * Math.PI*2;
      const a2 = angle0 + ((i+1)/seg) * Math.PI*2;

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, R, a1, a2);
      ctx.closePath();

      if (i === panel.missingI) {
        ctx.fillStyle = "#fff";
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Question mark in wedge (approx center)
        const am = (a1 + a2)/2;
        const rx = cx + Math.cos(am) * (R*0.55);
        const ry = cy + Math.sin(am) * (R*0.55);
        drawCenterText(ctx, "?", rx, ry, R*0.25, Math.max(16, R*0.22), "#111");
      } else {
        ctx.fillStyle = palette[panel.seq[i]].hex;
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();
    }

    // Inner circle
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.arc(cx, cy, R*0.42, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.18)";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Tiny hint marker at top
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.beginPath();
    ctx.arc(cx, cy - R*0.92, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawReferenceOnCanvas(ctx, palette, x, y, w) {
    const pad = 10;
    const chipW = (w - pad*2) / 10;
    const h = 46;

    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.04)";
    drawRoundedRect(ctx, x, y, w, h, 12);
    ctx.fill();

    for (let i = 0; i < 10; i++) {
      const cx = x + pad + i*chipW;
      const cy = y + 10;
      const bw = chipW - 6;
      const bh = 26;

      ctx.fillStyle = palette[i].hex;
      drawRoundedRect(ctx, cx+3, cy, bw, bh, 7);
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.fillStyle = palette[i].text;
      ctx.font = `900 14px system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(String(i), cx+3 + bw/2, cy + bh/2);
    }
    ctx.restore();
  }

  function layoutPanels(w, h, count=5, top=32) {
    // Row of panels with margins and adjustable top offset.
    const margin = 22;
    const gap = 14;
    const availableW = w - 2*margin;
    const panelW = (availableW - gap*(count-1)) / count;
    const maxH = Math.max(120, h - top - 32);
    const panelH = Math.min(maxH, 420);

    const rects = [];
    for (let i = 0; i < count; i++) {
      rects.push({
        x: margin + i*(panelW + gap),
        y: top,
        w: panelW,
        h: panelH
      });
    }
    return rects;
  }

  // ---------- State ----------
  const ui = {
    w: document.getElementById("w"),
    h: document.getElementById("h"),
    pattern: document.getElementById("pattern"),
    difficulty: document.getElementById("difficulty"),
    granularity: document.getElementById("granularity"),
    difficultyVal: document.getElementById("difficultyVal"),
    granularityVal: document.getElementById("granularityVal"),
    seed: document.getElementById("seed"),
    randSeed: document.getElementById("randSeed"),
    scale: document.getElementById("scale"),
    scaleVal: document.getElementById("scaleVal"),
    offX: document.getElementById("offX"),
    offY: document.getElementById("offY"),
    resetView: document.getElementById("resetView"),
    newPuzzle: document.getElementById("newPuzzle"),
    download: document.getElementById("download"),
    print: document.getElementById("print"),
    swatches: document.getElementById("swatches"),
    refOnCanvas: document.getElementById("refOnCanvas"),
  };

  const palette = generateDistinctPalette10();
  let panels = [];

  const view = { scale: 1.0, offX: 0, offY: 0 };

  function buildReferenceTable() {
    ui.swatches.innerHTML = "";
    for (let d = 0; d < 10; d++) {
      const el = document.createElement("div");
      el.className = "swatch";
      const chip = document.createElement("div");
      chip.className = "chip";
      chip.style.background = palette[d].hex;
      chip.style.color = palette[d].text;
      chip.textContent = d;
      const txt = document.createElement("div");
      txt.innerHTML = `<div style="font-weight:800">Digit ${d}</div><div class="tiny">${palette[d].hex.toUpperCase()}</div>`;
      el.appendChild(chip);
      el.appendChild(txt);
      ui.swatches.appendChild(el);
    }
  }

  function currentSeedString() {
    const s = (ui.seed.value || "").trim();
    return s.length ? s : String(Date.now());
  }

  function regeneratePuzzle() {
    const seedStr = currentSeedString();
    const rng = makeRng(seedStr + "|" + ui.pattern.value + "|" + ui.difficulty.value + "|" + ui.granularity.value);

    const difficulty = Number(ui.difficulty.value);
    const granularity = Number(ui.granularity.value);

    panels = [];
    for (let i = 0; i < 5; i++) {
      const type = (ui.pattern.value === "mixed") ? rng.pick(PATTERNS) : ui.pattern.value;
      const p = generatePanel(type, rng, difficulty, granularity);
      panels.push(p);
    }

    render();
  }

  function render() {
    const { w, h, dpr } = setCanvasSize();

    // Clear in device pixels
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Apply dpr + camera
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.translate(view.offX, view.offY);
    ctx.scale(view.scale, view.scale);

    // Background
    ctx.save();
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, w, h);
    ctx.restore();

    let panelTop = 24;

    // Optional reference table on canvas (useful for PNG export)
    if (ui.refOnCanvas.checked) {
      const refW = Math.min(w - 44, 820);
      drawReferenceOnCanvas(ctx, palette, 22, panelTop, refW);
      panelTop += 46 + 18; // height + margin
    }

    // Panels
    const panelRects = layoutPanels(w, h, panels.length, panelTop);
    for (let i = 0; i < panels.length; i++) {
      const p = panels[i];
      const pr = panelRects[i];
      switch (p.kind) {
        case "progression": drawProgression(ctx, pr, p, palette); break;
        case "sum":         drawSum(ctx, pr, p, palette); break;
        case "mirror":      drawMirror(ctx, pr, p, palette); break;
        case "radial":      drawRadial(ctx, pr, p, palette); break;
      }
    }
  }

  // ---------- Interactions ----------
  function syncUIValues() {
    ui.difficultyVal.textContent = ui.difficulty.value;
    ui.granularityVal.textContent = ui.granularity.value;

    ui.scaleVal.textContent = ui.scale.value;
    view.scale = Number(ui.scale.value) / 100;

    view.offX = Number(ui.offX.value) || 0;
    view.offY = Number(ui.offY.value) || 0;
  }

  function randomSeedString() {
    // A friendly short seed
    const words = ["ember","violet","orbit","mango","vector","delta","prism","tango","quartz","fjord","nova","pixel"];
    const r = makeRng(String(Date.now()));
    return `${words[r.int(words.length)]}-${(r.int(90000)+10000)}`;
  }

  ui.randSeed.addEventListener("click", () => {
    ui.seed.value = randomSeedString();
    regeneratePuzzle();
  });

  ui.newPuzzle.addEventListener("click", () => {
    if (!ui.seed.value.trim()) ui.seed.value = randomSeedString();
    else ui.seed.value = ui.seed.value.trim() + "!";
    regeneratePuzzle();
  });

  ui.download.addEventListener("click", () => {
    // Ensure latest draw at native resolution
    render();
    const link = document.createElement("a");
    link.download = `color-puzzle-${(ui.seed.value || "seed").replace(/[^\w-]+/g,"_")}.png`;
    link.href = canvas.toDataURL("image/png");
    link.click();
  });

  ui.print.addEventListener("click", () => window.print());

  ui.resetView.addEventListener("click", () => {
    ui.scale.value = "100";
    ui.offX.value = "0";
    ui.offY.value = "0";
    syncUIValues();
    render();
  });

  // Regenerate when settings change
  ["change","input"].forEach(evt => {
    ui.pattern.addEventListener(evt, regeneratePuzzle);
    ui.difficulty.addEventListener(evt, () => { syncUIValues(); regeneratePuzzle(); });
    ui.granularity.addEventListener(evt, () => { syncUIValues(); regeneratePuzzle(); });
    ui.seed.addEventListener(evt, regeneratePuzzle);
    ui.refOnCanvas.addEventListener(evt, render);
    ui.w.addEventListener(evt, render);
    ui.h.addEventListener(evt, render);
  });

  ["input","change"].forEach(evt => {
    ui.scale.addEventListener(evt, () => { syncUIValues(); render(); });
    ui.offX.addEventListener(evt, () => { syncUIValues(); render(); });
    ui.offY.addEventListener(evt, () => { syncUIValues(); render(); });
  });

  // Canvas drag-pan + wheel-zoom
  let dragging = false;
  let last = { x: 0, y: 0 };

  canvas.addEventListener("pointerdown", (e) => {
    dragging = true;
    canvas.setPointerCapture(e.pointerId);
    last.x = e.clientX;
    last.y = e.clientY;
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const dx = e.clientX - last.x;
    const dy = e.clientY - last.y;
    last.x = e.clientX;
    last.y = e.clientY;

    view.offX += dx;
    view.offY += dy;
    ui.offX.value = String(Math.round(view.offX));
    ui.offY.value = String(Math.round(view.offY));
    render();
  });

  canvas.addEventListener("pointerup", () => { dragging = false; });
  canvas.addEventListener("pointercancel", () => { dragging = false; });

  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();

    // Cursor position in logical (CSS px) coordinates
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Convert to world coords before zoom
    const wx = (mx - view.offX) / view.scale;
    const wy = (my - view.offY) / view.scale;

    const zoom = Math.exp(-e.deltaY * 0.0015);
    view.scale = clamp(view.scale * zoom, 0.5, 2.5);

    // Keep point under cursor stable
    view.offX = mx - wx * view.scale;
    view.offY = my - wy * view.scale;

    ui.scale.value = String(Math.round(view.scale * 100));
    ui.scaleVal.textContent = ui.scale.value;
    ui.offX.value = String(Math.round(view.offX));
    ui.offY.value = String(Math.round(view.offY));

    render();
  }, { passive: false });

  // ---------- Init ----------
  function init() {
    buildReferenceTable();
    ui.seed.value = randomSeedString();
    syncUIValues();
    regeneratePuzzle();
  }

  window.addEventListener("resize", () => render());
  init();
})();
</script>
</body>
</html>
